<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- M√©ta-tags pour forcer l'orientation portrait -->
    <meta name="screen-orientation" content="portrait">
    <meta name="x5-orientation" content="portrait">
    <meta name="msapplication-orientation" content="portrait">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>TiDash Game</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <!-- Pr√©chargement des sons -->
    <audio id="userTapSound" src="sounds/UserTap.mp3" preload="auto"></audio>
    <audio id="successSound" src="sounds/Success.mp3" preload="auto"></audio>
    <audio id="gameOverSound" src="sounds/Termine.mp3" preload="auto"></audio>
    <audio id="showScoreSound" src="sounds/Show_GameOver.mp3" preload="auto"></audio>
    <audio id="borderTouchSound" src="sounds/BorderTouch.mp3" preload="auto"></audio>
    <!-- √âl√©ment audio pour la musique de fond -->
    <audio id="backgroundMusic" preload="auto" loop></audio>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        
        body {
            font-family: 'Orbitron', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #0A0A0A; /* Noir presque pur */
            overflow: hidden;
            touch-action: manipulation;
            position: relative;
        }
        
        .container {
            position: relative;
            width: 90%;
            max-width: 400px;
            height: 90vh; /* Augment√© de 80vh √† 90vh pour r√©duire l'espace vertical */
            max-height: 800px; /* Augment√© pour maintenir les proportions */
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            background-color: #121212; /* Gris tr√®s fonc√© */
            border: 10px solid #0A0A0A;
            margin: 20px auto; /* Ajout d'une marge automatique pour centrer avec moins d'espace vertical */
        }
        
        #game-canvas {
            background-color: #121212; /* Gris tr√®s fonc√© - m√™me que le container */
            background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)); /* M√™me superposition que le home-screen */
            display: block;
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 1;
        }
        
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #121212; /* Gris tr√®s fonc√© - m√™me que le container */
            background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)); /* M√™me superposition que le home-screen */
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
            font-family: 'Orbitron', sans-serif;
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }
        
        #game-over.visible {
            opacity: 1;
        }
        
        #score-display {
            font-size: 4rem;
            margin-bottom: 10px;
            color: #00FF9D; /* Vert original */
            font-weight: bold;
            transform: translateY(20px);
            opacity: 0;
            transition: all 0.5s ease-out;
            transition-delay: 0.3s;
        }
        
        #best-score {
            font-size: 1.8rem;
            margin-bottom: 30px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #season-score {
            font-size: 1.8rem;
            margin-bottom: 30px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: none;
        }
        
        .button-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            transform: translateY(20px);
            opacity: 0;
            transition: all 0.5s ease-out;
            transition-delay: 0.9s;
        }
        
        #game-over.visible #score-display,
        #game-over.visible #best-score,
        #game-over.visible #season-score,
        #game-over.visible .button-container {
            transform: translateY(0);
            opacity: 1;
        }
        
        #home-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 0;
            box-sizing: border-box;
            pointer-events: auto;
            z-index: 5;
            background-color: rgba(0, 0, 0, 0.3); /* L√©g√®rement transparent */
        }
        
        #game-title-container {
            text-align: center;
            margin-bottom: 50px;
            z-index: 6;
        }
        
        #game-button-container {
            text-align: center;
            margin-top: 50px;
            z-index: 6;
        }
        
        .button-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #game-title {
            font-size: 4.5rem;
            font-weight: bold;
            color: #FFFFFF;
            letter-spacing: 2px;
            text-shadow: 
                0 2px 0 rgba(0, 0, 0, 0.5),
                0 4px 0 rgba(0, 255, 157, 0.3),
                0 6px 10px rgba(0, 0, 0, 0.3);
            transform: perspective(500px) rotateX(10deg);
            margin-bottom: 10px;
        }
        
        #score-display {
            font-size: 4rem;
            margin-bottom: 10px;
            color: #00FF9D; /* Vert original */
            font-weight: bold;
        }
        
        #best-score {
            font-size: 1.8rem;
            margin-bottom: 30px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .game-button {
            padding: 12px 24px;
            font-size: 1.2rem;
            background: linear-gradient(135deg, #00FF9D 0%, #00B38B 70%, #009E7F 100%);
            color: #121212;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            margin: 10px 0;
            min-width: 150px;
            text-align: center;
            font-weight: bold;
            letter-spacing: 1px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            text-transform: uppercase;
        }
        
        .game-button:hover {
            background: linear-gradient(135deg, #00FFB3 0%, #00C49C 70%, #00AF8F 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
        }
        
        .game-button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .game-button.secondary {
            background: transparent;
            color: white;
            border: 2px solid white;
            box-shadow: none;
        }
        
        .game-button.secondary:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        
        /* Style pour le profil utilisateur */
        .user-profile {
            position: absolute;
            top: 20px;
            right: 20px;
            left: auto;
            display: flex;
            align-items: center;
            z-index: 10;
            flex-direction: row-reverse; /* Inverser l'ordre pour mettre l'avatar √† droite */
        }
        
        .avatar-container {
            position: relative;
            width: 32px;
            height: 32px;
            margin-left: 6px;
            margin-right: 0;
        }
        
        .avatar-border {
            position: absolute;
            top: -1.5px;
            left: -1.5px;
            right: -1.5px;
            bottom: -1.5px;
            border: 2px solid #00FF9D;
            border-radius: 50%;
            box-sizing: border-box;
        }
        
        .avatar-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
        }
        
        .user-info {
            color: white;
            text-align: right; /* Aligner le texte √† droite */
        }
        
        .username {
            font-size: 11px;
            font-weight: bold;
            margin: 0;
            margin-bottom: 2px; /* Espacement entre username et ID */
        }
        
        .user-id {
            font-size: 9px;
            color: #aaa;
            margin: 0;
        }
        
        /* Styles pour la page de param√®tres */
        #settings-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: none;
            z-index: 100;
        }
        
        .android-scroll-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
        }
        
        .settings-content {
            padding: 20px;
            box-sizing: border-box;
            color: white;
            padding-bottom: 100px; /* Espace suppl√©mentaire en bas pour faciliter le d√©filement */
        }
        
        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }
        
        .settings-title {
            font-size: 24px;
            font-weight: bold;
            color: white;
        }
        
        .close-button {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        
        .close-button:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        
        .close-icon {
            color: white;
            font-size: 20px;
        }
        
        .profile-card {
            background-color: rgba(30, 30, 30, 0.8);
            border-radius: 12px;
            padding: 15px;
            display: flex;
            align-items: center;
            margin-bottom: 30px;
        }
        
        .profile-avatar {
            width: 70px;
            height: 70px;
            border-radius: 12px;
            margin-right: 15px;
            position: relative;
            overflow: hidden;
        }
        
        .profile-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .profile-avatar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 2px solid #00FF9D;
            border-radius: 12px;
            box-sizing: border-box;
        }
        
        .profile-info {
            flex: 1;
        }
        
        .username-container {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .username-input {
            background-color: transparent;
            border: none;
            color: white;
            font-size: 18px;
            font-weight: bold;
            font-family: 'Orbitron', sans-serif;
            padding: 5px 0;
            width: calc(100% - 30px);
            outline: none;
        }
        
        .edit-icon {
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-left: 10px;
        }
        
        .user-id-display {
            font-size: 14px;
            color: #aaa;
        }
        
        .paypal-section {
            margin-bottom: 30px;
        }
        
        .section-title {
            font-size: 16px;
            color: white;
            margin-bottom: 15px;
        }
        
        .paypal-input {
            width: 100%;
            background-color: rgba(30, 30, 30, 0.8);
            border: none;
            border-radius: 8px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            padding: 12px 15px;
            box-sizing: border-box;
            margin-bottom: 15px;
            outline: none;
        }
        
        .input-container {
            position: relative;
            margin-bottom: 15px;
        }
        
        .input-edit-icon {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: white;
        }
        
        .description-text {
            font-size: 12px;
            color: #aaa;
            line-height: 1.5;
        }
        
        .avatars-section {
            margin-bottom: 30px;
            position: relative;
            z-index: 2;
            padding-bottom: 30px; /* Ajouter de l'espace en bas */
        }
        
        .avatars-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 15px;
            padding: 0 10px;
        }
        
        .avatar-item {
            position: relative;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            overflow: hidden;
            border: 2px solid #333;
            cursor: pointer;
            transition: all 0.2s ease;
            margin: 0 auto;
        }
        
        .avatar-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .avatar-item.selected {
            border: 2px solid #4CAF50;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.8);
        }
        
        .avatar-check {
            position: absolute;
            bottom: 0;
            right: 0;
            background-color: #4CAF50;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            opacity: 0;
        }
        
        .avatar-item.selected .avatar-check {
            opacity: 1;
        }
        
        /* Optimisation des images d'avatar */
        .preload-images {
            position: absolute;
            width: 0;
            height: 0;
            overflow: hidden;
            z-index: -1;
        }
        
        /* Styles pour le bouton de son */
        .sound-toggle {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 100;
            transition: all 0.2s ease;
        }
        
        .sound-toggle:hover {
            background-color: rgba(0, 0, 0, 0.7);
            transform: scale(1.1);
        }
        
        .sound-toggle svg {
            width: 24px;
            height: 24px;
        }
        
        .sound-toggle.muted .sound-on {
            display: none;
        }
        
        .sound-toggle:not(.muted) .sound-off {
            display: none;
        }
        
        /* Correction pour iOS */
        .avatars-wrapper {
            position: relative;
            padding-bottom: 60px; /* Espace suppl√©mentaire en bas */
        }
        
        .ios-spacer {
            height: 60px; /* Espace suppl√©mentaire pour √©viter la zone noire */
            width: 100%;
        }
        
        /* Styles sp√©cifiques pour les appareils Android */
        .android-device {
            -webkit-tap-highlight-color: transparent; /* D√©sactiver le surlignage au toucher sur Android */
        }
    </style>
</head>
<body>
    <div class="preload-images" id="preload-container"></div>
    <div class="container">
        <!-- Profil utilisateur -->
        <div class="user-profile" id="profile-button">
            <div class="avatar-container">
                <div class="avatar-border"></div>
                <img id="avatarImg" class="avatar-img" src="avatars/avatar_default.jpg" alt="Avatar">
            </div>
            <div class="user-info">
                <p id="username" class="username">Username</p>
                <p id="userId" class="user-id">0000000000</p>
            </div>
        </div>
        
        <canvas id="game-canvas"></canvas>
        
        <div id="home-screen">
            <div id="game-title-container">
                <div id="game-title">TiDash</div>
            </div>
            <div id="game-button-container">
                <button id="play-button" class="game-button">Tap to Start</button>
            </div>
            
            <!-- Bouton pour activer/d√©sactiver le son -->
            <div id="sound-toggle" class="sound-toggle muted">
                <svg class="sound-on" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M14.5 8.5C14.5 8.5 16 9.57 16 12C16 14.43 14.5 15.5 14.5 15.5" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M18 5C18 5 21 7 21 12C21 17 18 19 18 19" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M3 10.5V13.5C3 14.6046 3.5 15.5 5 15.5C6.5 15.5 7 14.6046 7 13.5V10.5C7 9.39543 6.5 8.5 5 8.5C3.5 8.5 3 9.39543 3 10.5Z" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M7 10L11 7V17L7 14" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <svg class="sound-off" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M2 9L22 21" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M11 7L7 10H5C3.5 10 3 10.8954 3 12V12C3 13.1046 3.5 14 5 14H7L11 17V7Z" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M14.5 10.5C14.5 10.5 15.0049 10.7705 15.5 11.5" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M18 8C18 8 19.5 9.5 19.5 12" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </div>
        </div>
        <div id="game-over">
            <div id="score-display">0</div>
            <div id="best-score">Best: 0</div>
            <div id="season-score" style="font-size: 2.2rem; color: #00FF9D; font-weight: bold; margin-bottom: 20px;">Season Best: 0</div>
            <div class="button-container">
                <button id="play-again" class="game-button">PLAY AGAIN</button>
                <button id="home-button" class="game-button secondary">HOME</button>
            </div>
        </div>
        
        <!-- Page de param√®tres -->
        <div id="settings-screen">
            <div class="android-scroll-container">
                <div class="settings-content">
                    <div class="settings-header">
                        <div class="settings-title">Settings</div>
                        <div class="close-button" id="close-settings">
                            <span class="close-icon">‚úï</span>
                        </div>
                    </div>
                    
                    <div class="profile-card">
                        <div class="profile-avatar">
                            <img id="settings-avatar" src="avatars/avatar_default.jpg" alt="Avatar">
                        </div>
                        <div class="profile-info">
                            <div class="username-container">
                                <input type="text" id="username-input" class="username-input" value="Username">
                                <div class="edit-icon">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M16.4745 5.40768L18.5917 7.52483M17.8358 3.54254L11.6002 9.77806C11.3979 9.98031 11.2619 10.2384 11.2104 10.5192L10.5798 13.4209L13.4816 12.7903C13.7624 12.7388 14.0205 12.6028 14.2227 12.4006L20.4582 6.16508C20.5844 6.03889 20.6846 5.88909 20.7536 5.72343C20.8226 5.55777 20.8589 5.37966 20.8605 5.19938C20.8621 5.01909 20.8289 4.84039 20.7628 4.6736C20.6967 4.50681 20.5991 4.35537 20.4749 4.22718C20.3507 4.09899 20.2022 3.99691 20.0374 3.92553C19.8726 3.85415 19.6951 3.81549 19.5157 3.81169C19.3364 3.8079 19.1574 3.83906 18.9899 3.90281C18.8224 3.96656 18.6698 4.06188 18.5401 4.18348L12.3046 10.419C12.1023 10.6212 11.9664 10.8793 11.9149 11.1601L11.2843 14.0619L14.186 13.4313C14.4668 13.3798 14.7249 13.2438 14.9272 13.0416L21.1627 6.80608C21.8106 6.15818 22.1655 5.28206 22.1529 4.36728C22.1403 3.45249 21.7612 2.58647 21.0961 1.9549C20.431 1.32333 19.5401 0.96993 18.6146 1.00182C17.689 1.03372 16.8179 1.44959 16.1974 2.12483L9.96196 8.36035C9.35302 8.96929 8.94371 9.74882 8.79747 10.5981L7.7655 15.2322C7.73328 15.3697 7.73471 15.5131 7.76969 15.6498C7.80467 15.7864 7.87221 15.9122 7.96643 16.0172C8.06066 16.1222 8.17871 16.2034 8.31082 16.2544C8.44293 16.3054 8.58559 16.3247 8.72856 16.3108L13.3627 15.2788C14.212 15.1326 14.9915 14.7233 15.6004 14.1143L21.8359 7.87877L16.4745 5.40768Z" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </div>
                        </div>
                        <div class="user-id-display">ID : <span id="settings-user-id">0000000000</span></div>
                    </div>
                </div>
                
                <div class="paypal-section">
                    <div class="section-title">Enter your PayPal email address</div>
                    <div class="input-container">
                        <input type="email" id="paypal-email" class="paypal-input" placeholder="mypaypal@email.com">
                        <div class="input-edit-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M16.4745 5.40768L18.5917 7.52483M17.8358 3.54254L11.6002 9.77806C11.3979 9.98031 11.2619 10.2384 11.2104 10.5192L10.5798 13.4209L13.4816 12.7903C13.7624 12.7388 14.0205 12.6028 14.2227 12.4006L20.4582 6.16508C20.5844 6.03889 20.6846 5.88909 20.7536 5.72343C20.8226 5.55777 20.8589 5.37966 20.8605 5.19938C20.8621 5.01909 20.8289 4.84039 20.7628 4.6736C20.6967 4.50681 20.5991 4.35537 20.4749 4.22718C20.3507 4.09899 20.2022 3.99691 20.0374 3.92553C19.8726 3.85415 19.6951 3.81549 19.5157 3.81169C19.3364 3.8079 19.1574 3.83906 18.9899 3.90281C18.8224 3.96656 18.6698 4.06188 18.5401 4.18348L12.3046 10.419C12.1023 10.6212 11.9664 10.8793 11.9149 11.1601L11.2843 14.0619L14.186 13.4313C14.4668 13.3798 14.7249 13.2438 14.9272 13.0416L21.1627 6.80608C21.8106 6.15818 22.1655 5.28206 22.1529 4.36728C22.1403 3.45249 21.7612 2.58647 21.0961 1.9549C20.431 1.32333 19.5401 0.96993 18.6146 1.00182C17.689 1.03372 16.8179 1.44959 16.1974 2.12483L9.96196 8.36035C9.35302 8.96929 8.94371 9.74882 8.79747 10.5981L7.7655 15.2322C7.73328 15.3697 7.73471 15.5131 7.76969 15.6498C7.80467 15.7864 7.87221 15.9122 7.96643 16.0172C8.06066 16.1222 8.17871 16.2034 8.31082 16.2544C8.44293 16.3054 8.58559 16.3247 8.72856 16.3108L13.3627 15.2788C14.212 15.1326 14.9915 14.7233 15.6004 14.1143L21.8359 7.87877L16.4745 5.40768Z" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </div>
                    </div>
                    <div class="description-text">
                        This is where your prize money will be sent if you win 1st place in the season ranking. Make sure your PayPal account is active and the email entered is correct, as this is how we will transfer your winnings!
                    </div>
                </div>
                
                <div class="avatars-section">
                    <div class="avatars-wrapper">
                        <div class="section-title">Select your avatar</div>
                        <div class="avatars-grid" id="avatars-grid">
                            <!-- Les avatars seront ajout√©s dynamiquement ici -->
                        </div>
                        <div class="ios-spacer"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const tg = window.Telegram.WebApp;
        const gameOverScreen = document.getElementById('game-over');
        const homeScreen = document.getElementById('home-screen');
        const scoreDisplay = document.getElementById('score-display');
        const bestScoreDisplay = document.getElementById('best-score');
        const seasonScoreDisplay = document.getElementById('season-score');
        const playAgainBtn = document.getElementById('play-again');
        const homeBtn = document.getElementById('home-button');
        const playBtn = document.getElementById('play-button');

        // D√©sactiver le zoom sur mobile
        document.addEventListener('touchmove', function (event) {
            if (event.scale !== 1) {
                event.preventDefault();
            }
        }, { passive: false });
        
        // Double-tap prevention
        document.addEventListener('touchend', function(event) {
            const now = Date.now();
            const DOUBLE_TAP_THRESHOLD = 300;
            if (now - lastTouchEnd <= DOUBLE_TAP_THRESHOLD) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
        
        let lastTouchEnd = 0;

        // Game variables
        let gameRunning = false;
        let gameMode = 'home'; // 'home', 'game', 'gameOver'
        let score = 0;
        let bestScore = 0; // Sera initialis√© correctement dans initUserProfile
        let seasonScore = 0; // Ajout d'une variable pour suivre le score de la saison en cours
        
        // Variables pour les √©toiles
        let stars = [];
        const maxStars = 45; // Nombre d'√©toiles
        
        // Variables pour le profil utilisateur
        let username = "";
        let userId = "";
        let avatarSrc = "/avatars/avatar_default.jpg";
        let paypalEmail = "";
        
        // Variables pour la musique de fond
        let homeMusics = [
            "home_musics/dont-talk-315229.mp3",
            "home_musics/Onchain.mp3",
            "home_musics/gardens-stylish-chill-303261.mp3",
            "home_musics/gorila-315977 (1).mp3",
            "home_musics/ClicClic.mp3",
            "home_musics/night-detective-226857.mp3",
            "home_musics/movement.mp3",
            "home_musics/drive-breakbeat.mp3",
            "home_musics/glossy.mp3",
            "home_musics/the-best-jazz-club.mp3",
            "home_musics/lofi-chill.mp3",
            "home_musics/unlock-me.mp3",
            "home_musics/relaxed-vlog-night.mp3",
            "home_musics/password-infinity.mp3",
            "home_musics/weeknds.mp3",
            "home_musics/guitar-electro-sport-trailer.mp3"
        ];
        let currentMusicIndex = -1;
        let backgroundMusicElement = document.getElementById('backgroundMusic');
        
        // Variable pour suivre si la musique est en attente d'autoplay
        window.musicPendingAutoplay = true;
        
        // Variables pour g√©rer s√©par√©ment la musique de fond et les effets sonores
        let isMusicEnabled = false; // Contr√¥le uniquement la musique de fond
        let isGameSoundEnabled = true; // Contr√¥le uniquement les effets sonores du jeu (toujours activ√©s par d√©faut)
        let userPrefersMusicEnabled = false; // Changed from localStorage to variable
        
        // Variable pour suivre si la musique a d√©j√† √©t√© activ√©e par l'utilisateur
        let musicActivatedByUser = false;
        
        // Syst√®me audio optimis√© pour mobile avec Web Audio API
        let audioContext;
        const audioBuffers = {};
        const audioSources = {};
        let audioInitialized = false;
        
        // Initialiser le syst√®me audio
        function initAudioSystem() {
            try {
                // Cr√©er le contexte audio
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                audioContext = new AudioContext();
                
                // Pr√©charger les sons
                preloadSounds();
                
                // Marquer comme initialis√©
                audioInitialized = true;
                
                console.log("Syst√®me audio initialis√©");
            } catch (error) {
                console.error("Erreur d'initialisation audio:", error);
                // Fallback √† la m√©thode standard si Web Audio API n'est pas support√©e
                audioInitialized = false;
            }
        }
        
        // Pr√©charger les sons pour une lecture instantan√©e
        function preloadSounds() {
            const sounds = {
                'userTap': document.getElementById('userTapSound'),
                'success': document.getElementById('successSound'),
                'gameOver': document.getElementById('gameOverSound'),
                'showScore': document.getElementById('showScoreSound'),
                'borderTouch': document.getElementById('borderTouchSound')
            };
            
            // Pour chaque son
            for (const [name, audioElement] of Object.entries(sounds)) {
                if (!audioElement) continue;
                
                // Stocker l'√©l√©ment audio pour le fallback
                audioSources[name] = audioElement;
                
                // Pr√©charger avec Web Audio API
                if (audioContext) {
                    fetch(audioElement.src)
                        .then(response => response.arrayBuffer())
                        .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
                        .then(audioBuffer => {
                            audioBuffers[name] = audioBuffer;
                            console.log(`Son ${name} pr√©charg√©`);
                        })
                        .catch(error => {
                            console.error(`Erreur lors du pr√©chargement du son ${name}:`, error);
                        });
                }
            }
        }
        
        // Jouer un son avec le moins de latence possible
        function playSound(name) {
            // Ne jouer les sons que si on est en mode jeu et si le son est activ√©
            if (gameMode !== 'game' && name === 'borderTouch') {
                return;
            }
            
            if (!isGameSoundEnabled) {
                return;
            }
            
            // Si le syst√®me audio n'est pas initialis√©, l'initialiser
            if (!audioInitialized && typeof AudioContext !== 'undefined') {
                initAudioSystem();
            }
            
            try {
                // Si Web Audio API est disponible et le son est pr√©charg√©
                if (audioInitialized && audioContext && audioBuffers[name]) {
                    // V√©rifier si le contexte est suspendu (restriction mobile)
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                    
                    // Cr√©er une source sonore
                    const source = audioContext.createBufferSource();
                    source.buffer = audioBuffers[name];
                    
                    // Connecter √† la sortie audio
                    source.connect(audioContext.destination);
                    
                    // Jouer imm√©diatement
                    source.start(0);
                    return;
                }
                
                // Fallback √† la m√©thode standard
                if (audioSources[name]) {
                    const audio = audioSources[name];
                    audio.currentTime = 0;
                    
                    // Utiliser une promesse pour g√©rer la lecture
                    const playPromise = audio.play();
                    if (playPromise !== undefined) {
                        playPromise.catch(error => {
                            console.error(`Erreur de lecture audio (${name}):`, error);
                            
                            // Si l'erreur est li√©e √† l'interaction utilisateur, initialiser le syst√®me audio
                            if (error.name === 'NotAllowedError') {
                                // On ne peut rien faire ici, il faut une interaction utilisateur
                                console.log("Interaction utilisateur requise pour la lecture audio");
                            }
                        });
                    }
                }
            } catch (error) {
                console.error(`Erreur lors de la lecture du son ${name}:`, error);
            }
        }
        
        // Activer l'audio sur interaction utilisateur
        function setupAudioActivation() {
            const activateAudio = () => {
                // Initialiser le syst√®me audio
                if (!audioInitialized) {
                    initAudioSystem();
                }
                
                // Jouer un son silencieux pour d√©bloquer l'audio sur mobile
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log("Contexte audio repris");
                        
                        // Cr√©er un oscillateur silencieux pour "r√©veiller" l'audio
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        gainNode.gain.value = 0; // Volume √† 0
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        oscillator.start(0);
                        oscillator.stop(audioContext.currentTime + 0.001); // Jouer pendant 1ms
                    });
                }
                
                // Supprimer les √©couteurs d'√©v√©nements
                document.removeEventListener('click', activateAudio, true);
                document.removeEventListener('touchstart', activateAudio, true);
                document.removeEventListener('keydown', activateAudio, true);
            };
            
            // Ajouter les √©couteurs d'√©v√©nements
            document.addEventListener('click', activateAudio, true);
            document.addEventListener('touchstart', activateAudio, true);
            document.addEventListener('keydown', activateAudio, true);
        }
        
        let ball = {
            x: 0,
            y: 0,
            radius: 0,
            speed: 0,
            direction: 1 // 1 for right, -1 for left
        };
        let line = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        };
        let squares = [];
        let fadingSquares = []; // Squares that are fading out
        let particles = []; // Particles for ball explosion
        let gameOverAnimation = false;
        let gameOverAnimationComplete = false;
        let lastSquareTime = 0;
        let squareInterval = 1100; // Intervalle augment√© pour r√©duire la difficult√©
        let lastFrameTime = 0;
        let greenSquareChance = 0.2; // 20% chance for green squares
        let lineProximityThreshold = 0; // Distance minimale entre les carr√©s et la ligne
        let canSpawnNewSquare = true; // Variable pour contr√¥ler l'apparition des carr√©s

        // Return to home screen
        function goToHome() {
            // Nettoyer l'√©tat du jeu
            squares = [];
            fadingSquares = [];
            particles = [];
            
            // Changer le mode de jeu
            gameMode = 'home';
            
            // Masquer l'√©cran de game over et afficher l'√©cran d'accueil
            gameOverScreen.style.display = 'none';
            homeScreen.style.display = 'flex';
            
            // R√©initialiser les variables d'animation
            gameOverAnimation = false;
            gameOverAnimationComplete = false;
            
            // R√©initialiser la position de la balle et de la ligne pour l'√©cran d'accueil
            ball.x = canvas.width / 2;
            ball.y = canvas.height * 0.5;
            ball.direction = Math.random() > 0.5 ? 1 : -1;
            ball.speed = canvas.width * 0.0008;
            
            // R√©initialiser la position de la ligne
            line.x = (canvas.width - line.width) / 2;
            line.y = ball.y - ball.radius;
            
            // Effacer compl√®tement le canvas pour √©viter les artefacts visuels
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // R√©afficher le profil utilisateur sur l'√©cran d'accueil
            document.getElementById("profile-button").style.display = 'flex';
            
            // Assurer que la boucle de jeu est en cours d'ex√©cution pour l'animation de l'√©cran d'accueil
            if (!gameRunning) {
                gameRunning = true;
                lastFrameTime = null;
                if (window.gameLoopAnimationId) {
                    cancelAnimationFrame(window.gameLoopAnimationId);
                }
                window.gameLoopAnimationId = requestAnimationFrame(gameLoop);
            }
            
            // G√©rer la musique de fond (d√©marrer sur l'√©cran d'accueil)
            manageBackgroundMusic();
            
            console.log("üéÆ Retour √† l'√©cran d'accueil");
        }

        // Initialize the game
        function initGame() {
            console.log("üéÆ Initialisation du jeu...");
            
            // Set canvas size to match container
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            // Set initial game mode to home screen
            gameMode = 'home';
            
            // Initialize ball - larger radius
            ball.radius = canvas.width * 0.035;
            ball.y = canvas.height * 0.5; // Middle of the screen vertically
            ball.x = canvas.width / 2;
            ball.speed = canvas.width * 0.0008; // Slightly faster speed
            ball.direction = Math.random() > 0.5 ? 1 : -1; // Direction al√©atoire comme dans goToHome()
            
            // Initialize line - 80% of width and same height as ball
            line.width = canvas.width * 0.8;
            line.height = ball.radius * 2; // Same height as the ball diameter
            line.x = (canvas.width - line.width) / 2;
            line.y = ball.y - ball.radius; // Center the ball on the line
            
            // Initialiser les √©toiles
            initStars();
            
            // Configurer l'activation audio
            setupAudioActivation();
            
            // Initialiser le profil utilisateur
            initUserProfile();
            
            // Envoyer les donn√©es utilisateur au serveur pour le panneau d'admin
            sendUserDataToServer();
            
            // Reset game state
            squares = [];
            fadingSquares = [];
            particles = [];
            gameOverAnimation = false;
            gameOverAnimationComplete = false;
            score = 0;
            
            // R√©initialiser le temps de frame pour √©viter les sauts
            lastFrameTime = null;
            
            // Assurer que la boucle de jeu est en cours d'ex√©cution pour l'animation de l'√©cran d'accueil
            // Utiliser la m√™me approche que dans goToHome()
            gameRunning = true;
            
            // Annuler l'animation frame pr√©c√©dente si elle existe
            if (window.gameLoopAnimationId) {
                cancelAnimationFrame(window.gameLoopAnimationId);
            }
            
            // D√©marrer une nouvelle boucle de jeu
            window.gameLoopAnimationId = requestAnimationFrame(gameLoop);
            
            console.log("üéÆ Jeu initialis√© avec la balle en mouvement sur l'√©cran d'accueil");
        }
        
        // Initialiser les √©toiles
        function initStars() {
            stars = [];
            for (let i = 0; i < maxStars; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 1.2 + 0.3, // Taille entre 0.3 et 1.5 pixels
                    opacity: Math.random() * 0.4 + 0.3, // Opacit√© entre 0.3 et 0.7 (augment√©e pour plus de visibilit√©)
                    speed: Math.random() * 0.2 + 0.05, // Vitesse entre 0.05 et 0.25 pixels par frame
                    direction: Math.random() * Math.PI * 2 // Direction al√©atoire en radians
                });
            }
        }
        
        // Dessiner les √©toiles
        function drawStars() {
            // Ne dessiner les √©toiles que sur l'√©cran d'accueil et pendant le jeu
            if (gameMode === 'home' || gameMode === 'game') {
                for (let i = 0; i < stars.length; i++) {
                    const star = stars[i];
                    
                    // Mise √† jour de la position
                    star.x += Math.cos(star.direction) * star.speed;
                    star.y += Math.sin(star.direction) * star.speed;
                    
                    // Si l'√©toile sort de l'√©cran, la replacer de l'autre c√¥t√©
                    if (star.x < 0) star.x = canvas.width;
                    if (star.x > canvas.width) star.x = 0;
                    if (star.y < 0) star.y = canvas.height;
                    if (star.y > canvas.height) star.y = 0;
                    
                    // Dessiner l'√©toile
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
                    ctx.fill();
                }
            }
        }

        // Start the actual gameplay
        function startGame() {
            console.log("üéÆ Starting new game from home screen");
            
            // Hide home screen
            homeScreen.style.display = 'none';
            
            // Masquer le profil utilisateur pendant le jeu
            document.getElementById("profile-button").style.display = 'none';
            
            // Effacer compl√®tement le canvas pour √©viter les artefacts visuels
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Reset game state - Utiliser la fonction resetGame() sans r√©initialiser √† nouveau
            resetGame();
            
            // Play sound effect
            playSound('userTap');
        }

        // Game loop
        function gameLoop(timestamp) {
            // G√©rer le deltaTime avec une limite maximale pour √©viter les comportements erratiques apr√®s pause
            if (!lastFrameTime) lastFrameTime = timestamp;
            let deltaTime = timestamp - lastFrameTime;
            
            // Limiter deltaTime √† 100ms max pour √©viter les sauts trop grands apr√®s pause/inactivit√©
            if (deltaTime > 100) deltaTime = 100;
            
            lastFrameTime = timestamp;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Dessiner les √©toiles en arri√®re-plan
            drawStars();
            
            // Mettre √† jour la position de la balle pour tous les modes (y compris l'√©cran d'accueil)
            // La balle doit bouger sur l'√©cran d'accueil mais sans faire de son
            if (gameMode !== 'gameOver' || !gameOverAnimation) {
                ball.x += ball.speed * ball.direction * deltaTime;
                
                // Check if ball hits the edge of the line
                if (ball.x - ball.radius < line.x) {
                    ball.x = line.x + ball.radius;
                    ball.direction = 1;
                    
                    // Only play border touch sound during gameplay, not on home screen
                    if (gameMode === 'game') {
                        playSound('borderTouch');
                    }
                } else if (ball.x + ball.radius > line.x + line.width) {
                    ball.x = line.x + line.width - ball.radius;
                    ball.direction = -1;
                    
                    // Only play border touch sound during gameplay, not on home screen
                    if (gameMode === 'game') {
                        playSound('borderTouch');
                    }
                }
            }
            
            // Always draw the line
            drawLine();
            
            // Ne dessiner la balle que si on n'est pas en animation de game over
            if (gameMode !== 'gameOver' || !gameOverAnimation) {
                drawBall();
            }
            
            // Gestion des √©l√©ments de jeu (particules, carr√©s, etc.)
            if (gameMode === 'game' || gameMode === 'gameOver') {
                // Update and draw particles - D√©placer avant les carr√©s pour que les particules soient visibles
                updateParticles(deltaTime);
                
                // Update and draw squares
                updateSquares(deltaTime);
                
                // Update and draw fading squares
                updateFadingSquares(deltaTime);
                
                // V√©rifier si l'animation de game over est termin√©e
                if (gameMode === 'gameOver' && gameOverAnimation && particles.length === 0 && fadingSquares.length === 0) {
                    gameOverAnimationComplete = true;
                    console.log("üí• Game over animation completed");
                }
                
                if (gameMode === 'game') {
                    // Check for collisions
                    if (checkCollisions()) {
                        // Ne pas quitter la boucle de jeu, laisser l'animation de game over se d√©rouler
                        console.log("üí• Collision detected, starting game over animation");
                    } else {
                        // Spawn new squares seulement si on n'est pas en game over
                        if ((squares.length === 0) || (squares.length > 0 && squares[squares.length-1].y > canvas.height * 0.20)) {
                            spawnSquare();
                            lastSquareTime = Date.now();
                            
                            // Gradually decrease spawn interval
                            if (squareInterval > 500) {
                                squareInterval -= 10;
                            }
                        }
                    }
                    
                    // Draw score
                    drawScore();
                }
            }
            
            // Continue the game loop avec une meilleure gestion des animation frames
            if (gameRunning) {
                // Annuler l'animation frame pr√©c√©dente si elle existe
                if (window.gameLoopAnimationId) {
                    cancelAnimationFrame(window.gameLoopAnimationId);
                }
                
                // Demander une nouvelle frame
                window.gameLoopAnimationId = requestAnimationFrame(gameLoop);
            } else if (window.gameLoopAnimationId) {
                // Nettoyer l'animation frame si le jeu est arr√™t√©
                cancelAnimationFrame(window.gameLoopAnimationId);
                window.gameLoopAnimationId = null;
            }
        }

        // Spawn a new square
        function spawnSquare() {
            // Larger squares
            const size = canvas.width * 0.07;
            
            // Make sure squares pass through the horizontal line
            // Calculate a position that will ensure the square passes through the line
            const lineCenter = line.x + line.width / 2;
            const lineWidth = line.width;
            
            // Random position that ensures passing through the line
            const minX = Math.max(0, line.x - size);
            const maxX = Math.min(canvas.width - size, line.x + line.width);
            const x = minX + Math.random() * (maxX - minX);
            
            const isGreen = Math.random() < greenSquareChance;
            
            // Random diagonal angle for falling, but ensure it passes through the line
            const targetX = line.x + Math.random() * line.width;
            const targetY = line.y;
            
            // Calculate angle to ensure it passes through the line
            const dx = targetX - (x + size/2);
            const dy = targetY - (-size/2);
            const angle = Math.atan2(dx, dy);
            
            // Limit the angle to prevent too horizontal trajectories
            const limitedAngle = Math.max(Math.min(angle, Math.PI/4), -Math.PI/4);
            
            squares.push({
                x: x,
                y: -size,
                size: size,
                speed: canvas.height * 0.0005, // Revenir √† la vitesse originale
                isGreen: isGreen,
                rotation: 0,
                rotationSpeed: 0.01 * (Math.random() > 0.5 ? 1 : -1), // Vitesse de rotation fixe et mod√©r√©e
                angle: limitedAngle,
                velocityX: Math.sin(limitedAngle),
                velocityY: Math.cos(limitedAngle)
            });
        }

        // Update squares positions
        function updateSquares(deltaTime) {
            // Update regular squares
            for (let i = squares.length - 1; i >= 0; i--) {
                const square = squares[i];
                
                if (!gameOverAnimation) {
                    // Move square diagonally
                    square.x += square.velocityX * square.speed * deltaTime;
                    square.y += square.velocityY * square.speed * deltaTime;
                }
                
                // Update rotation
                square.rotation += square.rotationSpeed * deltaTime;
                
                // Check if square has reached the bottom area (above score)
                const scoreAreaY = canvas.height * 0.7; // Position plus haute (70% au lieu de 80%)
                
                if (square.y > scoreAreaY && !gameOverAnimation) {
                    // Add to fading squares and remove from regular squares
                    square.fadeStartTime = Date.now();
                    square.fadeTime = 1500; // 1.5 seconds for fade animation
                    square.originalSize = square.size;
                    fadingSquares.push(square);
                    squares.splice(i, 1);
                    continue;
                }
                
                // Remove squares that are off-screen horizontally
                if ((square.x < -square.size || square.x > canvas.width) && !gameOverAnimation) {
                    squares.splice(i, 1);
                    continue;
                }
                
                // Draw rotating square
                ctx.save();
                ctx.translate(square.x + square.size/2, square.y + square.size/2);
                ctx.rotate(square.rotation);
                ctx.fillStyle = square.isGreen ? '#00FF9D' : '#FFFFFF'; // Couleur verte pour les carr√©s verts
                ctx.fillRect(-square.size/2, -square.size/2, square.size, square.size);
                ctx.restore();
            }
        }

        // Update fading squares
        function updateFadingSquares(deltaTime) {
            for (let i = fadingSquares.length - 1; i >= 0; i--) {
                const square = fadingSquares[i];
                
                // Calculate how much time has passed since fade started
                const fadeElapsed = Date.now() - square.fadeStartTime;
                const fadeProgress = Math.min(fadeElapsed / square.fadeTime, 1);
                
                // Update rotation (continue rotating while fading)
                square.rotation += square.rotationSpeed * deltaTime;
                
                // Calculate new size based on fade progress (shrink to nothing)
                const newSize = square.originalSize * (1 - fadeProgress);
                
                // Remove if fade is complete
                if (fadeProgress >= 1) {
                    fadingSquares.splice(i, 1);
                    continue;
                }
                
                // Draw fading square
                ctx.save();
                ctx.translate(square.x + square.originalSize/2, square.y + square.originalSize/2);
                ctx.rotate(square.rotation);
                ctx.fillStyle = square.isGreen ? '#00FF9D' : '#FFFFFF'; // Couleur verte pour les carr√©s verts
                ctx.globalAlpha = 1 - fadeProgress; // Also fade opacity
                ctx.fillRect(-newSize/2, -newSize/2, newSize, newSize);
                ctx.globalAlpha = 1;
                ctx.restore();
            }
        }

        // Create explosion particles from the ball
        function createExplosion(x, y, color) {
            console.log(`üí• Creating explosion at (${x}, ${y}) with color ${color}`);
            
            const particleCount = 120; // Augmenter l√©g√®rement le nombre de particules
            const particleSize = ball.radius / 4; // Particules plus fines (divis√© par 4 au lieu de 2)
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 8 + 3; // Vitesse plus √©lev√©e
                const distance = Math.random() * ball.radius;
                
                particles.push({
                    x: x + Math.cos(angle) * distance,
                    y: y + Math.sin(angle) * distance,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: particleSize * (Math.random() * 0.5 + 0.3), // Particules plus fines
                    color: color || '#00FF9D',
                    alpha: 1,
                    fadeSpeed: 0.01 + Math.random() * 0.02, // Ralentir la disparition
                    creationTime: Date.now() // Ajouter un timestamp de cr√©ation pour d√©bogage
                });
            }
        }

        // Update and draw particles
        function updateParticles(deltaTime) {
            // Si aucune particule, ne rien faire
            if (particles.length === 0) return;
            
            // Limiter le deltaTime pour les particules pour √©viter les comportements erratiques
            const particleDeltaTime = Math.min(deltaTime, 100);
            
            // Tracer le nombre de particules pour d√©bogage
            if (particles.length > 0 && particles.length % 50 === 0) {
                console.log(`‚ú® Updating ${particles.length} particles`);
            }
            
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                // V√©rifier si la particule est trop ancienne (plus de 10 secondes) pour √©viter les fuites de m√©moire
                const particleAge = Date.now() - (particle.creationTime || Date.now());
                if (particleAge > 10000) { // 10 secondes max
                    particles.splice(i, 1);
                    continue;
                }
                
                // Update position - avec un facteur de vitesse constant pour √©viter les variations de deltaTime
                particle.x += particle.vx * particleDeltaTime * 0.1;
                particle.y += particle.vy * particleDeltaTime * 0.1;
                
                // Update alpha - ralentir la disparition
                particle.alpha -= particle.fadeSpeed * particleDeltaTime * 0.03;
                
                // Remove faded particles
                if (particle.alpha <= 0) {
                    particles.splice(i, 1);
                    continue;
                }
                
                // Draw particle
                ctx.save();
                ctx.globalAlpha = particle.alpha;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore(); // Toujours restaurer le contexte pour r√©initialiser globalAlpha
            }
        }

        // Draw the ball
        function drawBall() {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#00FF9D'; // Vert original
            ctx.fill();
            ctx.closePath();
        }

        // Draw the line
        function drawLine() {
            // Draw the actual line with rounded corners
            ctx.fillStyle = '#333333';
            
            // Use rounded rectangle
            const radius = line.height / 2;
            ctx.beginPath();
            ctx.moveTo(line.x + radius, line.y);
            ctx.lineTo(line.x + line.width - radius, line.y);
            ctx.arcTo(line.x + line.width, line.y, line.x + line.width, line.y + radius, radius);
            ctx.lineTo(line.x + line.width, line.y + line.height - radius);
            ctx.arcTo(line.x + line.width, line.y + line.height, line.x + line.width - radius, line.y + line.height, radius);
            ctx.lineTo(line.x + radius, line.y + line.height);
            ctx.arcTo(line.x, line.y + line.height, line.x, line.y + line.height - radius, radius);
            ctx.lineTo(line.x, line.y + radius);
            ctx.arcTo(line.x, line.y, line.x + radius, line.y, radius);
            ctx.closePath();
            ctx.fill();
        }
        
        // Draw score at the bottom
        function drawScore() {
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold ' + (canvas.width * 0.2) + 'px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(score.toString(), canvas.width / 2, canvas.height * 0.85);
        }

        // Check for collisions between ball and squares
        function checkCollisions() {
            for (let i = 0; i < squares.length; i++) {
                const square = squares[i];
                
                // Calculate distance between ball and square center
                const dx = ball.x - (square.x + square.size / 2);
                const dy = ball.y - (square.y + square.size / 2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Check if ball collides with square
                if (distance < ball.radius + square.size / 2) {
                    // If it's a green square, collect it
                    if (square.isGreen) {
                        // Jouer le son quand la balle touche un carr√© vert
                        playSound('success');
                        
                        // Remove the square
                        squares.splice(i, 1);
                        
                        // Increment score
                        score++;
                        
                        // Update season score if current score is better
                        if (score > seasonScore) {
                            seasonScore = score;
                            console.log(`üèÜ New season best: ${seasonScore}`);
                        }
                        
                        // Update best score if needed
                        if (score > bestScore) {
                            bestScore = score;
                            console.log(`üåü New all-time best: ${bestScore}`);
                        }
                        
                        // Create explosion effect
                        createExplosion(square.x + square.size / 2, square.y + square.size / 2, '#00FF9D');
                        
                        // Send the updated score to the server immediately
                        sendUserDataToServer();
                        
                        return false;
                    } else {
                        // Game over if it's a white square
                        // Jouer le son quand la balle touche un carr√© blanc
                        playSound('gameOver');
                        
                        // Set game over mode first to prevent multiple collisions
                        gameMode = 'gameOver';
                        gameOverAnimation = true;
                        gameOverAnimationComplete = false;
                        
                        console.log("üéÆ Game over sequence started");
                        
                        // Cr√©er un effet d'explosion uniquement pour la balle
                        createExplosion(ball.x, ball.y, '#00FF9D');
                        
                        // Ajouter tous les carr√©s au tableau des carr√©s en train de disparaitre
                        // pour qu'ils disparaissent progressivement comme √† la fin de leur chute
                        for (let i = 0; i < squares.length; i++) {
                            const square = squares[i];
                            
                            // Ajouter le carr√© aux carr√©s en train de disparaitre
                            fadingSquares.push({
                                x: square.x,
                                y: square.y,
                                originalSize: square.size,
                                rotation: square.rotation,
                                rotationSpeed: square.rotationSpeed,
                                isGreen: square.isGreen,
                                fadeStartTime: Date.now(),
                                fadeTime: 1000 // Disparition en 1 seconde
                            });
                        }
                        
                        // Vider le tableau des carr√©s originaux puisqu'ils sont maintenant en train de disparaitre
                        squares.length = 0;
                        
                        // Afficher l'√©cran de game over avec un d√©lai plus long pour voir l'animation compl√®te
                        setTimeout(() => {
                            showGameOverScreen();
                        }, 1000); // D√©lai augment√© pour voir l'animation compl√®te
                        
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Function to show game over screen
        function showGameOverScreen() {
            // Jouer le son quand le popup de score s'affiche
            playSound('showScore');
            
            // Update score display
            document.getElementById('score-display').textContent = score;
            document.getElementById('best-score').textContent = `Best: ${bestScore}`;
            
            // CRITICAL FIX: Handle season score correctly on game over
            const seasonScoreElement = document.getElementById('season-score');
            if (seasonScoreElement) {
                // V√©rifier s'il y a une saison active
                fetch('/api/seasons/active')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Error retrieving active season');
                    }
                    return response.json();
                })
                .then(data => {
                    if (data && data.id) {
                        console.log(`üîç Active season found: ${data.id}, Season ${data.seasonNumber}`);
                        
                        fetch(`/api/seasons/${data.id}/scores/${userId}`)
                        .then(response => response.ok ? response.json() : { score: 0 })
                        .then(serverData => {
                            // Use the server's score as the source of truth
                            let serverSeasonBest = serverData && serverData.score ? parseInt(serverData.score) : 0;
                            
                            console.log(`üéÆ Game Over - Current game score: ${score}, Server season best: ${serverSeasonBest}`);
                            
                            // IMPORTANT FIX: Always check if we need to update the season score
                            // We need to handle two cases:
                            // 1. If this is the first game in a new season, we should send the score regardless
                            // 2. If the current score is better than the stored season best
                            
                            // Check with the server if this is a new season for the user
                            const isFirstGame = serverSeasonBest === 0;
                            
                            if (isFirstGame || score > serverSeasonBest) {
                                // Update our local variable
                                if (score > serverSeasonBest) {
                                    seasonScore = score;
                                    console.log(`üèÜ New season best achieved: ${seasonScore}`);
                                } else {
                                    console.log(`üìä First game in new season: ${score}`);
                                    // Even if it's not a personal best, we need to record it for the first game
                                    seasonScore = score;
                                }
                                
                                // Send updated score to server immediately
                                sendUserDataToServer();
                            } else {
                                // If we didn't update the score, make sure we're using the server's value
                                seasonScore = serverSeasonBest;
                            }
                            
                            // CRITICAL FIX: Always display the season score, regardless of whether it was updated
                            // This ensures the season score is always visible in the game over popup
                            seasonScoreElement.textContent = `Season ${data.seasonNumber} Best: ${seasonScore} üèÜ`;
                            seasonScoreElement.style.display = 'block';
                        })
                        .catch(error => {
                            console.error('‚ùå Error getting season score from server:', error);
                            // Fallback to local data if server request fails
                            seasonScoreElement.textContent = `Season ${data.seasonNumber} Best: ${score} üèÜ`;
                            seasonScoreElement.style.display = 'block';
                        });
                    } else {
                        seasonScoreElement.style.display = 'none';
                    }
                })
                .catch(error => {
                    console.error('‚ùå Error checking active season:', error);
                    seasonScoreElement.style.display = 'none';
                });
            }
            
            // Mettre √† jour le mode de jeu
            gameMode = 'gameOver';
            
            // G√©rer la musique de fond (arr√™ter pendant le game over)
            manageBackgroundMusic();
            
            // Afficher l'√©cran de game over
            const gameOverScreen = document.getElementById('game-over');
            gameOverScreen.style.display = 'flex';
            
            // Forcer un reflow pour que la transition fonctionne
            void gameOverScreen.offsetWidth;
            
            // Ajouter la classe visible pour d√©clencher l'animation
            gameOverScreen.classList.add('visible');
            console.log("Game over screen displayed");
        }
        
        // Function to hide game over screen
        function hideGameOver() {
            // Masquer imm√©diatement l'√©cran de game over sans animation
            gameOverScreen.style.display = 'none';
            // R√©initialiser la classe visible pour les futures utilisations
            gameOverScreen.classList.remove('visible');
            
            // R√©initialiser l'√©tat de l'animation de fin de jeu
            gameOverAnimation = false;
            gameOverAnimationComplete = false;
        }

        // Function to reset the game and start a new game
        function resetGame() {
            console.log("üîÑ Resetting game completely");
            
            // Hide game over screen
            hideGameOver();
            
            // Annuler l'animation frame pr√©c√©dente pour √©viter les doublons
            if (window.gameLoopAnimationId) {
                cancelAnimationFrame(window.gameLoopAnimationId);
                window.gameLoopAnimationId = null;
            }
            
            // Effacer compl√®tement le canvas pour √©viter les artefacts visuels
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Reset game state - vider compl√®tement les tableaux pour √©viter les fuites de m√©moire
            squares.length = 0;
            fadingSquares.length = 0;
            particles.length = 0;
            
            // R√©initialiser les variables de jeu
            gameOverAnimation = false;
            gameOverAnimationComplete = false;
            score = 0;
            
            // Update game mode
            gameMode = 'game';
            
            // Reset ball position and speed
            ball.x = canvas.width / 2;
            ball.y = canvas.height * 0.5;
            ball.direction = Math.random() > 0.5 ? 1 : -1;
            ball.speed = canvas.width * 0.0008;
            
            // Reset line position
            line.x = (canvas.width - line.width) / 2;
            line.y = ball.y - ball.radius;
            
            // Reset spawn interval
            squareInterval = 1000; // Reset to initial spawn interval
            lastSquareTime = Date.now();
            
            // Hide profile button during gameplay
            document.getElementById("profile-button").style.display = 'none';
            
            // Manage background music for game mode
            manageBackgroundMusic();
            
            // R√©initialiser le temps de frame pour √©viter les sauts
            lastFrameTime = null;
            
            // Ensure the game loop is properly reset and running
            gameRunning = true;
            
            // Forcer un nouveau d√©marrage de la boucle de jeu
            window.gameLoopAnimationId = requestAnimationFrame(gameLoop);
            
            // Play sound effect
            playSound('userTap');
            
            console.log("üéÆ Game reset and restarted");
        }

        // Handle screen tap/click
        function handleTap() {
            if (gameMode === 'game') {
                // Change ball direction
                ball.direction *= -1;
                
                // Jouer le son quand l'utilisateur touche l'√©cran
                playSound('userTap');
            }
        }

        // Resize handler
        function resizeCanvas() {
            // Set canvas size to match container
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            // Adjust ball size based on canvas width
            ball.radius = canvas.width * 0.035;
            
            // Adjust line dimensions
            line.width = canvas.width * 0.8;
            line.height = ball.radius * 2;
            
            // Reposition ball and line
            if (gameMode === 'home') {
                // On home screen, position in the middle
                ball.x = canvas.width / 2;
                ball.y = canvas.height * 0.5;
                line.x = (canvas.width - line.width) / 2;
                line.y = ball.y - ball.radius;
            }
            
            // Redraw stars for new dimensions
            initStars();
            
            console.log(`üì± Canvas resized to ${canvas.width}x${canvas.height}`);
        }

        // Handle window resize
        function handleResize() {
            // Delay resize to avoid performance issues during resize
            clearTimeout(window.resizeTimer);
            window.resizeTimer = setTimeout(function() {
                resizeCanvas();
            }, 250);
        }

        // Add resize event listener
        window.addEventListener('resize', handleResize);

        // Event listeners
        canvas.addEventListener('click', handleTap);
        
        // Handle play again button click
        playAgainBtn.addEventListener('click', resetGame);

        playBtn.addEventListener('click', startGame);

        // G√©n√©rer un nom d'utilisateur al√©atoire
        function generateRandomUsername() {
            const adjectives = [
                "Cosmic", "Stellar", "Quantum", "Neon", "Cyber", 
                "Digital", "Pixel", "Techno", "Hyper", "Mega", 
                "Ultra", "Retro", "Future", "Laser", "Plasma", 
                "Crystal", "Glitch", "Vector", "Synth", "Astro"
            ];
            
            const nouns = [
                "Runner", "Racer", "Dasher", "Pilot", "Navigator", 
                "Explorer", "Voyager", "Jumper", "Drifter", "Surfer", 
                "Rider", "Hunter", "Ninja", "Warrior", "Knight", 
                "Wizard", "Hacker", "Gamer", "Player", "Master"
            ];
            
            const randomAdjective = adjectives[Math.floor(Math.random() * adjectives.length)];
            const randomNoun = nouns[Math.floor(Math.random() * nouns.length)];
            
            return randomAdjective + randomNoun;
        }
        
        // G√©n√©rer un ID √† 10 chiffres
        function generateRandomUserId() {
            let id = "";
            for (let i = 0; i < 10; i++) {
                id += Math.floor(Math.random() * 10);
            }
            return id;
        }
        
        // S√©lectionner un avatar al√©atoire
        function getRandomAvatar() {
            return "/avatars/avatar_default.jpg";
        }
        
        // Initialiser ou r√©cup√©rer le profil utilisateur
        function initUserProfile() {
            try {
                console.log("üë§ Initializing user profile...");
                
                // V√©rifier d'abord si nous avons d√©j√† un ID utilisateur en m√©moire
                // Cela aidera √† √©viter la r√©initialisation des donn√©es lors du rechargement de la page
                const storedUserId = localStorage.getItem("tidashUserId");
                const storedUsername = localStorage.getItem("tidashUsername");
                
                if (storedUserId) {
                    console.log("üíæ Found stored user ID in localStorage:", storedUserId);
                }
                
                // Get device ID from cookie (plus persistant que localStorage)
                let deviceId = getCookie("tidashDeviceId");
                if (!deviceId) {
                    deviceId = generateRandomUserId();
                    setCookie("tidashDeviceId", deviceId, 365); // Cookie valide 1 an
                    console.log("üÜï Generated new device ID:", deviceId);
                } else {
                    console.log("üì± Found existing device ID in cookie:", deviceId);
                }
                
                // Fetch user data from server using device ID
                fetch(`/api/users/device/${deviceId}`)
                    .then(response => {
                        if (response.status === 404) {
                            // User not found, create a new user
                            console.log("üë§ User not found on server, creating new user...");
                            
                            // Generate random user ID and username
                            userId = storedUserId || generateRandomUserId();
                            username = storedUsername || generateRandomUsername();
                            
                            // Create new user data
                            const userData = {
                                gameId: userId,
                                gameUsername: username,
                                bestScore: 0,
                                seasonScore: 0,
                                musicEnabled: true
                            };
                            
                            console.log("üìù Creating new user:", userData);
                            
                            // Send new user data to server
                            return fetch('/api/users', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify(userData)
                            })
                            .then(response => {
                                if (!response.ok) {
                                    throw new Error('Failed to create user');
                                }
                                return response.json();
                            })
                            .then(data => {
                                console.log("‚úÖ New user created:", data);
                                
                                // Stocker l'ID et le nom d'utilisateur localement pour la persistance
                                localStorage.setItem("tidashUserId", userId);
                                localStorage.setItem("tidashUsername", username);
                                
                                // Update UI
                                updateUserProfileDisplay();
                                updateScoreDisplay();
                                updateSoundToggleDisplay();
                                
                                return null; // Return null to indicate we've handled this case
                            });
                        } else if (!response.ok) {
                            throw new Error('Failed to fetch user data');
                        } else {
                            return response.json();
                        }
                    })
                    .then(data => {
                        if (data) {
                            console.log("‚úÖ User data loaded from server:", data);
                            
                            // IMPORTANT: Conserver les donn√©es existantes de l'utilisateur
                            // Ne pas g√©n√©rer de nouveaux ID ou noms d'utilisateur s'ils existent d√©j√†
                            let needsUpdate = false;
                            
                            // Utiliser l'ID du serveur s'il existe
                            if (data.gameId) {
                                userId = data.gameId;
                                console.log("üë§ Using existing game ID from server:", userId);
                                // Mettre √† jour le stockage local
                                localStorage.setItem("tidashUserId", userId);
                            } 
                            // Sinon, utiliser l'ID stock√© localement s'il existe
                            else if (storedUserId) {
                                userId = storedUserId;
                                needsUpdate = true;
                                console.log("üíæ Using stored game ID from localStorage:", userId);
                            } 
                            // En dernier recours, g√©n√©rer un nouvel ID
                            else {
                                userId = generateRandomUserId();
                                needsUpdate = true;
                                console.log("üÜï Generated new game ID as last resort:", userId);
                                localStorage.setItem("tidashUserId", userId);
                            }
                            
                            // M√™me logique pour le nom d'utilisateur
                            if (data.gameUsername) {
                                username = data.gameUsername;
                                console.log("üë§ Using existing username from server:", username);
                                localStorage.setItem("tidashUsername", username);
                            } 
                            else if (storedUsername) {
                                username = storedUsername;
                                needsUpdate = true;
                                console.log("üíæ Using stored username from localStorage:", username);
                            } 
                            else {
                                username = generateRandomUsername();
                                needsUpdate = true;
                                console.log("üÜï Generated new username as last resort:", username);
                                localStorage.setItem("tidashUsername", username);
                            }
                            
                            // Handle avatar path correctly
                            if (data.avatarSrc) {
                                // Ensure avatar path is absolute
                                if (data.avatarSrc.startsWith('http')) {
                                    avatarSrc = data.avatarSrc;
                                } else if (data.avatarSrc.startsWith('/')) {
                                    avatarSrc = window.location.origin + data.avatarSrc;
                                } else {
                                    avatarSrc = window.location.origin + '/avatars/' + data.avatarSrc;
                                }
                            } else {
                                // Default avatar with absolute path
                                avatarSrc = window.location.origin + '/avatars/avatar_default.jpg';
                            }
                            
                            // Conserver les autres donn√©es utilisateur
                            paypalEmail = data.paypalEmail || "";
                            bestScore = parseInt(data.bestScore || "0");
                            seasonScore = parseInt(data.seasonScore || "0");
                            
                            // Set music preference from server
                            isMusicEnabled = data.musicEnabled !== undefined ? data.musicEnabled : true;
                            
                            // Only update the server if we needed to update ID or username
                            if (needsUpdate) {
                                console.log("üîÑ Updating user data on server with preserved information");
                                setTimeout(() => sendUserDataToServer(), 500);
                            } else {
                                console.log("‚úÖ User data is complete, no updates needed");
                            }
                            
                            // Update UI elements
                            updateUserProfileDisplay();
                            updateScoreDisplay();
                            updateSoundToggleDisplay();
                            
                            // Initialize avatar selection
                            initAvatarSelection();
                            
                            // Check for active season
                            checkForNewSeason();
                            
                            return data;
                        }
                        
                        // Fallback - utiliser les donn√©es stock√©es localement si disponibles
                        if (storedUserId && storedUsername) {
                            console.log("üíæ Falling back to stored user data due to server error");
                            userId = storedUserId;
                            username = storedUsername;
                            avatarSrc = window.location.origin + '/avatars/avatar_default.jpg';
                            
                            // Update UI elements
                            updateUserProfileDisplay();
                            updateScoreDisplay();
                            updateSoundToggleDisplay();
                        } else {
                            console.log("üîÑ No stored data available, creating temporary user");
                            // Cr√©er un utilisateur temporaire
                            userId = generateRandomUserId();
                            username = generateRandomUsername();
                            avatarSrc = window.location.origin + '/avatars/avatar_default.jpg';
                            
                            // Stocker localement
                            localStorage.setItem("tidashUserId", userId);
                            localStorage.setItem("tidashUsername", username);
                            
                            // Update UI elements
                            updateUserProfileDisplay();
                            updateScoreDisplay();
                            updateSoundToggleDisplay();
                        }
                    })
                    .catch(error => {
                        console.error("‚ùå Error initializing user profile:", error);
                    });
            } catch (error) {
                console.error("‚ùå Error in initUserProfile:", error);
                
                // Emergency fallback
                username = generateRandomUsername();
                userId = generateRandomUserId();
                avatarSrc = window.location.origin + '/avatars/avatar_default.jpg';
                
                // Update UI as a last resort
                updateUserProfileDisplay();
            }
        }
        
        // Function to populate the avatar grid
        function populateAvatarGrid() {
            try {
                console.log("üñºÔ∏è Populating avatar grid...");
                const avatarsGrid = document.getElementById('avatars-grid');
                
                // Clear existing avatars
                avatarsGrid.innerHTML = '';
                
                // List of available avatars (using the correct filenames)
                const avatars = [
                    'avatar_default.jpg',
                    'avatar1.jpg',
                    'avatar2.jpg',
                    'avatar3.jpg',
                    'avatar4.jpg',
                    'avatar5.jpg',
                    'avatar6.jpg',
                    'avatar7.jpg',
                    'avatar8.jpg',
                    'avatar9.jpg',
                    'avatar10.jpg',
                    'avatar11.jpg',
                    'avatar12.jpg',
                    'avatar13.jpg',
                    'avatar14.jpg',
                    'avatar15.jpg',
                    'avatar16.jpg',
                    'avatar17.jpg',
                    'avatar18.jpg',
                    'avatar19.jpg',
                    'avatar20.jpg'
                ];
                
                // Create avatar items
                avatars.forEach(avatar => {
                    const avatarItem = document.createElement('div');
                    avatarItem.className = 'avatar-item';
                    
                    const img = document.createElement('img');
                    img.src = `avatars/${avatar}`;
                    img.alt = 'Avatar';
                    
                    const check = document.createElement('div');
                    check.className = 'avatar-check';
                    check.innerHTML = '‚úì';
                    
                    avatarItem.appendChild(img);
                    avatarItem.appendChild(check);
                    avatarsGrid.appendChild(avatarItem);
                });
                
                console.log(`‚úÖ Added ${avatars.length} avatars to the grid`);
                
                // Initialize avatar selection
                initAvatarSelection();
            } catch (error) {
                console.error("‚ùå Error populating avatar grid:", error);
            }
        }

        // Function to initialize avatar selection
        function initAvatarSelection() {
            try {
                console.log("üñºÔ∏è Initializing avatar selection...");
                
                // Get all avatar items
                const avatarItems = document.querySelectorAll('.avatar-item');
                
                // Clear any existing selected state
                avatarItems.forEach(item => {
                    item.classList.remove('selected');
                });
                
                // Get current avatar filename
                const currentAvatarSrc = avatarSrc;
                const avatarFilename = currentAvatarSrc.split('/').pop();
                
                console.log(`üîç Looking for avatar: ${avatarFilename}`);
                
                // Find and select the matching avatar
                let found = false;
                avatarItems.forEach(item => {
                    const itemImg = item.querySelector('img');
                    if (itemImg && itemImg.src.includes(avatarFilename)) {
                        item.classList.add('selected');
                        found = true;
                        console.log(`‚úÖ Selected avatar: ${itemImg.src}`);
                    }
                });
                
                if (!found) {
                    console.log("‚ö†Ô∏è Matching avatar not found, selecting default");
                    // Select default avatar if no match found
                    const defaultAvatar = document.querySelector('.avatar-item:first-child');
                    if (defaultAvatar) {
                        defaultAvatar.classList.add('selected');
                    }
                }
                
                // Add click event listeners to avatar items
                avatarItems.forEach(item => {
                    item.addEventListener('click', function() {
                        // Remove selected class from all avatars
                        avatarItems.forEach(avatar => {
                            avatar.classList.remove('selected');
                        });
                        
                        // Add selected class to clicked avatar
                        this.classList.add('selected');
                        
                        // Get the src of the selected avatar
                        const selectedAvatarSrc = this.querySelector('img').src;
                        const avatarPath = '/avatars/' + selectedAvatarSrc.split('/').pop();
                        
                        // Update avatar in UI
                        document.getElementById('settings-avatar').src = selectedAvatarSrc;
                        document.getElementById('avatarImg').src = selectedAvatarSrc;
                        
                        // Update avatarSrc variable
                        avatarSrc = selectedAvatarSrc;
                        
                        // Save to server
                        sendUserDataToServer();
                        
                        console.log(`üñºÔ∏è Avatar updated: ${avatarPath}`);
                    });
                });
            } catch (error) {
                console.error("‚ùå Error initializing avatar selection:", error);
            }
        }
        
        // Function to update sound toggle display
        function updateSoundToggleDisplay() {
            try {
                const soundToggle = document.querySelector('.sound-toggle');
                if (soundToggle) {
                    if (isMusicEnabled) {
                        soundToggle.classList.remove('muted');
                    } else {
                        soundToggle.classList.add('muted');
                    }
                }
            } catch (error) {
                console.error("‚ùå Error updating sound toggle display:", error);
            }
        }
        
        // Function to send user data to server
        function sendUserDataToServer() {
            try {
                console.log("üì§ Sending user data to server...");
                
                // Get device ID from cookie
                const deviceId = getCookie("tidashDeviceId") || "";
                
                // Get Telegram data if available
                const telegramId = window.telegramId || "";
                const telegramUsername = window.telegramUsername || "";
                
                // Prepare user data
                const userData = {
                    gameId: userId,
                    gameUsername: username,
                    bestScore: bestScore,
                    seasonScore: seasonScore,
                    avatarSrc: avatarSrc.includes('/avatars/') ? 
                        '/avatars/' + avatarSrc.split('/avatars/').pop() : 
                        avatarSrc,
                    paypalEmail: paypalEmail,
                    deviceId: deviceId,
                    musicEnabled: isMusicEnabled,
                    telegramId: telegramId,
                    telegramUsername: telegramUsername
                };
                
                console.log("üìã User data to send:", userData);
                
                // Send data to server
                return fetch('/api/users', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(userData)
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to save user data');
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('‚úÖ User data saved successfully:', data);
                    
                    // Update user data from response if available
                    if (data.user) {
                        userId = data.user.gameId || userId;
                        bestScore = parseInt(data.user.bestScore || bestScore);
                        
                        // Update UI
                        updateUserProfileDisplay();
                        updateScoreDisplay();
                    }
                    
                    return data;
                })
                .catch(error => {
                    console.error('‚ùå Error saving user data:', error);
                });
            } catch (error) {
                console.error("‚ùå Error in sendUserDataToServer:", error);
            }
        }
        
        // Function to check for new season
        function checkForNewSeason(forceReset = false) {
            try {
                console.log("üîç Checking for active season...");
                
                fetch('/api/seasons/active')
                .then(response => {
                    if (!response.ok) {
                        if (response.status === 404) {
                            return null;
                        }
                        throw new Error('Error retrieving active season');
                    }
                    return response.json();
                })
                .then(data => {
                    if (!data) {
                        // No active season, reset season score
                        seasonScore = 0;
                        updateScoreDisplay();
                        return;
                    }
                    
                    console.log(`‚úÖ Active season found: ${data.id}, Season ${data.seasonNumber}`);
                    
                    // Get user's score for this season
                    return fetch(`/api/seasons/${data.id}/scores/${userId}`)
                    .then(response => response.ok ? response.json() : { score: 0 })
                    .then(serverData => {
                        // Use the server's score as the source of truth
                        let serverSeasonBest = serverData && serverData.score ? parseInt(serverData.score) : 0;
                        
                        console.log(`üéÆ Game Over - Current game score: ${score}, Server season best: ${serverSeasonBest}`);
                        
                        // IMPORTANT FIX: Always check if we need to update the season score
                        // We need to handle two cases:
                        // 1. If this is the first game in a new season, we should send the score regardless
                        // 2. If the current score is better than the stored season best
                        
                        // Check with the server if this is a new season for the user
                        const isFirstGame = serverSeasonBest === 0;
                        
                        if (isFirstGame || score > serverSeasonBest) {
                            // Update our local variable
                            if (score > serverSeasonBest) {
                                seasonScore = score;
                                console.log(`üèÜ New season best achieved: ${seasonScore}`);
                            } else {
                                console.log(`üìä First game in new season: ${score}`);
                                // Even if it's not a personal best, we need to record it for the first game
                                seasonScore = score;
                            }
                            
                            // Send updated score to server immediately
                            sendUserDataToServer();
                        } else {
                            // If we didn't update the score, make sure we're using the server's value
                            seasonScore = serverSeasonBest;
                        }
                        
                        // CRITICAL FIX: Always display the season score, regardless of whether it was updated
                        // This ensures the season score is always visible in the game over popup
                        const seasonScoreElement = document.getElementById('season-score');
                        if (seasonScoreElement) {
                            seasonScoreElement.textContent = `Season ${data.seasonNumber} Best: ${seasonScore} üèÜ`;
                            seasonScoreElement.style.display = 'block';
                        }
                    })
                    .catch(error => {
                        console.error('‚ùå Error getting season score from server:', error);
                        // Fallback to local data if server request fails
                        const seasonScoreElement = document.getElementById('season-score');
                        if (seasonScoreElement) {
                            seasonScoreElement.textContent = `Season ${data.seasonNumber} Best: ${score} üèÜ`;
                            seasonScoreElement.style.display = 'block';
                        }
                    });
                })
                .catch(error => {
                    console.error('‚ùå Error checking active season:', error);
                    const seasonScoreElement = document.getElementById('season-score');
                    if (seasonScoreElement) {
                        seasonScoreElement.style.display = 'none';
                    }
                });
            } catch (error) {
                console.error("‚ùå Error in checkForNewSeason:", error);
            }
        }
        
        // Helper function to get cookie value
        function getCookie(name) {
            const value = `; ${document.cookie}`;
            const parts = value.split(`; ${name}=`);
            if (parts.length === 2) return parts.pop().split(';').shift();
            return null;
        }
        
        // Helper function to set cookie
        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (value || "") + expires + "; path=/; SameSite=Strict";
        }
        
        // Function to update user profile display
        function updateUserProfileDisplay() {
            try {
                // Update username
                document.getElementById('username').textContent = username;
                
                // Update user ID
                document.getElementById('userId').textContent = userId;
                
                // Update avatar
                document.getElementById('avatarImg').src = avatarSrc;
                document.getElementById('settings-avatar').src = avatarSrc;
                
                // Update settings fields
                const usernameInput = document.getElementById('username-input');
                if (usernameInput) {
                    usernameInput.value = username;
                    usernameInput.placeholder = username;
                }
                
                const paypalInput = document.getElementById('paypal-email');
                if (paypalInput) {
                    paypalInput.value = paypalEmail || '';
                    paypalInput.placeholder = paypalEmail || 'mypaypal@email.com';
                }
                
                const settingsUserId = document.getElementById('settings-user-id');
                if (settingsUserId) {
                    settingsUserId.textContent = userId;
                }
            } catch (error) {
                console.error("‚ùå Error updating user profile display:", error);
            }
        }
        
        // Function to update score display
        function updateScoreDisplay() {
            try {
                // Update best score
                document.getElementById('best-score').textContent = `Best: ${bestScore}`;
                
                // Update season score
                const seasonScoreElement = document.getElementById('season-score');
                if (seasonScoreElement) {
                    seasonScoreElement.textContent = `Season Best: ${seasonScore} üèÜ`;
                }
            } catch (error) {
                console.error("‚ùå Error updating score display:", error);
            }
        }
        
        // Initialize the game
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize canvas dimensions
            resizeCanvas();
            
            // Initialize stars
            initStars();
            
            // Populate avatar grid
            populateAvatarGrid();
            
            // Initialize Telegram WebApp if available
            if (window.Telegram && window.Telegram.WebApp) {
                console.log("üì± Telegram WebApp detected, initializing...");
                try {
                    const tgWebApp = window.Telegram.WebApp;
                    
                    // Check if we have user data directly from the WebApp
                    if (tgWebApp.initDataUnsafe && tgWebApp.initDataUnsafe.user) {
                        const tgUser = tgWebApp.initDataUnsafe.user;
                        console.log("üë§ Telegram user data from WebApp:", tgUser);
                        
                        // Store Telegram user data for later use
                        window.telegramId = tgUser.id?.toString() || "";
                        window.telegramUsername = tgUser.username || "";
                        
                        console.log(`‚úÖ Telegram ID: ${window.telegramId}, Username: ${window.telegramUsername}`);
                    } else {
                        // Fallback to parsing initData string
                        const tgData = tgWebApp.initData || "";
                        if (tgData) {
                            console.log("üîç Parsing Telegram initData string");
                            try {
                                // Parse the initData to get user information
                                const urlParams = new URLSearchParams(tgData);
                                const userParam = urlParams.get('user');
                                if (userParam) {
                                    const tgUser = JSON.parse(decodeURIComponent(userParam));
                                    console.log("üë§ Telegram user data from initData:", tgUser);
                                    
                                    // Store Telegram user data for later use
                                    window.telegramId = tgUser.id?.toString() || "";
                                    window.telegramUsername = tgUser.username || "";
                                    
                                    console.log(`‚úÖ Telegram ID: ${window.telegramId}, Username: ${window.telegramUsername}`);
                                }
                            } catch (parseError) {
                                console.error("‚ùå Error parsing Telegram initData:", parseError);
                            }
                        }
                    }
                    
                    // Set up Telegram WebApp event handlers
                    tgWebApp.onEvent('viewportChanged', function() {
                        console.log("üì± Telegram viewport changed, resizing canvas...");
                        resizeCanvas();
                    });
                    
                    // Expand the WebApp to its maximum size
                    tgWebApp.expand();
                } catch (error) {
                    console.error("‚ùå Error initializing Telegram WebApp:", error);
                }
            }
            
            // Load user profile
            initUserProfile();
            
            // Envoyer les donn√©es utilisateur au serveur pour le panneau d'admin
            sendUserDataToServer();
            
            // Setup sound toggle
            const soundToggle = document.querySelector('.sound-toggle');
            if (soundToggle) {
                soundToggle.addEventListener('click', function() {
                    // Toggle music state
                    isMusicEnabled = !isMusicEnabled;
                    
                    // Update UI
                    if (isMusicEnabled) {
                        soundToggle.classList.remove('muted');
                        playBackgroundMusic();
                    } else {
                        soundToggle.classList.add('muted');
                        stopBackgroundMusic();
                    }
                    
                    // Save preference to server
                    saveSoundPreference(isMusicEnabled);
                });
            }
            
            // Setup game event listeners
            playAgainBtn.addEventListener('click', resetGame);
            homeBtn.addEventListener('click', goToHome);
            
            // Setup profile button
            const profileButton = document.getElementById('profile-button');
            if (profileButton) {
                profileButton.addEventListener('click', function() {
                    // Show settings screen
                    document.getElementById('settings-screen').style.display = 'block';
                });
            }
            
            // Setup settings close button
            const closeSettingsBtn = document.getElementById('close-settings');
            if (closeSettingsBtn) {
                closeSettingsBtn.addEventListener('click', function() {
                    // Hide settings screen
                    document.getElementById('settings-screen').style.display = 'none';
                });
            }
            
            // Setup username input
            const usernameInput = document.getElementById('username-input');
            if (usernameInput) {
                usernameInput.addEventListener('change', function() {
                    // Update username
                    username = this.value;
                    document.getElementById('username').textContent = username;
                    
                    // Save to server
                    sendUserDataToServer();
                });
            }
            
            // Setup PayPal email input
            const paypalEmailInput = document.getElementById('paypal-email');
            if (paypalEmailInput) {
                paypalEmailInput.addEventListener('change', function() {
                    // Update PayPal email
                    paypalEmail = this.value;
                    
                    // Save to server
                    sendUserDataToServer();
                });
            }
            
            // Initialiser le jeu correctement en appelant la fonction initGame()
            // au lieu de simplement d√©finir quelques variables
            initGame();
            
            // Note: initGame() s'occupe d√©j√† de d√©finir gameMode, d√©marrer la boucle de jeu, etc.
            // donc nous n'avons pas besoin de le faire ici
        });
        
        // Function to manage background music
        function manageBackgroundMusic() {
            if (gameMode === 'home') {
                // On home screen, play music if enabled
                if (isMusicEnabled) {
                    playBackgroundMusic();
                }
            } else if (gameMode === 'game') {
                // During gameplay, stop music
                stopBackgroundMusic();
            }
        }
        
        // Function to play background music
        function playBackgroundMusic() {
            try {
                if (!isMusicEnabled) return;
                
                const backgroundMusicElement = document.getElementById('backgroundMusic');
                if (!backgroundMusicElement) return;
                
                // If no music is currently selected or playing, pick a random one
                if (currentMusicIndex === -1 || backgroundMusicElement.paused) {
                    // Pick a random music from the list
                    const newIndex = Math.floor(Math.random() * homeMusics.length);
                    currentMusicIndex = newIndex;
                    
                    // Set the source
                    backgroundMusicElement.src = homeMusics[currentMusicIndex];
                    
                    // Set volume
                    backgroundMusicElement.volume = 0.3;
                    
                    // Play the music
                    const playPromise = backgroundMusicElement.play();
                    
                    // Handle autoplay restrictions
                    if (playPromise !== undefined) {
                        playPromise.catch(error => {
                            console.log('Autoplay prevented:', error);
                            window.musicPendingAutoplay = true;
                        });
                    }
                }
            } catch (error) {
                console.error('Error playing background music:', error);
            }
        }
        
        // Function to stop background music
        function stopBackgroundMusic() {
            try {
                const backgroundMusicElement = document.getElementById('backgroundMusic');
                if (backgroundMusicElement && !backgroundMusicElement.paused) {
                    backgroundMusicElement.pause();
                }
            } catch (error) {
                console.error('Error stopping background music:', error);
            }
        }
        
        // Function to save sound preference to server
        function saveSoundPreference(enabled) {
            try {
                // Send preference to server
                fetch('/api/users/preferences', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        userId: userId,
                        musicEnabled: enabled
                    })
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to save sound preference');
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Sound preference saved:', data);
                })
                .catch(error => {
                    console.error('Error saving sound preference:', error);
                });
            } catch (error) {
                console.error('Error in saveSoundPreference:', error);
            }
        }
        
        // Function to load sound preference from server
        function loadSoundPreference() {
            try {
                if (!userId) return;
                
                // Get preference from server
                fetch(`/api/users/${userId}/preferences`)
                    .then(response => {
                        if (!response.ok) {
                            if (response.status === 404) {
                                return { musicEnabled: false };
                            }
                            throw new Error('Failed to load sound preference');
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data && data.musicEnabled !== undefined) {
                            isMusicEnabled = data.musicEnabled;
                            userPrefersMusicEnabled = data.musicEnabled;
                            
                            // Update UI
                            const soundToggleBtn = document.getElementById('sound-toggle');
                            if (soundToggleBtn) {
                                soundToggleBtn.classList.toggle('muted', !isMusicEnabled);
                            }
                            
                            // Update music playback
                            if (isMusicEnabled && gameMode === 'home') {
                                playBackgroundMusic();
                            }
                        }
                    })
                    .catch(error => {
                        console.error('Error loading sound preference:', error);
                    });
            } catch (error) {
                console.error('Error in loadSoundPreference:', error);
            }
        }
    </script>
</body>
</html>
