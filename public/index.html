<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- Méta-tags pour forcer l'orientation portrait -->
    <meta name="screen-orientation" content="portrait">
    <meta name="x5-orientation" content="portrait">
    <meta name="msapplication-orientation" content="portrait">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>TiDash Game</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <!-- Préchargement des sons -->
    <audio id="userTapSound" src="sounds/UserTap.mp3" preload="auto"></audio>
    <audio id="successSound" src="sounds/Success.mp3" preload="auto"></audio>
    <audio id="gameOverSound" src="sounds/Termine.mp3" preload="auto"></audio>
    <audio id="showScoreSound" src="sounds/Show_GameOver.mp3" preload="auto"></audio>
    <audio id="borderTouchSound" src="sounds/BorderTouch.mp3" preload="auto"></audio>
    <!-- Élément audio pour la musique de fond -->
    <audio id="backgroundMusic" preload="auto" loop></audio>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        
        body {
            font-family: 'Orbitron', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #0A0A0A; /* Noir presque pur */
            overflow: hidden;
            touch-action: manipulation;
            position: relative;
        }
        
        .container {
            position: relative;
            width: 90%;
            max-width: 400px;
            height: 90vh; /* Augmenté de 80vh à 90vh pour réduire l'espace vertical */
            max-height: 800px; /* Augmenté pour maintenir les proportions */
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            background-color: #121212; /* Gris très foncé */
            border: 10px solid #0A0A0A;
            margin: 20px auto; /* Ajout d'une marge automatique pour centrer avec moins d'espace vertical */
        }
        
        #game-canvas {
            background-color: #121212; /* Gris très foncé - même que le container */
            background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)); /* Même superposition que le home-screen */
            display: block;
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 1;
        }
        
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #121212; /* Gris très foncé - même que le container */
            background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)); /* Même superposition que le home-screen */
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
            font-family: 'Orbitron', sans-serif;
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }
        
        #game-over.visible {
            opacity: 1;
        }
        
        #score-display {
            font-size: 4rem;
            margin-bottom: 10px;
            color: #00FF9D; /* Vert original */
            font-weight: bold;
            transform: translateY(20px);
            opacity: 0;
            transition: all 0.5s ease-out;
            transition-delay: 0.3s;
        }
        
        #best-score {
            font-size: 1.8rem;
            margin-bottom: 30px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #season-score {
            font-size: 1.8rem;
            margin-bottom: 30px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: none;
        }
        
        .button-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            transform: translateY(20px);
            opacity: 0;
            transition: all 0.5s ease-out;
            transition-delay: 0.9s;
        }
        
        #game-over.visible #score-display,
        #game-over.visible #best-score,
        #game-over.visible #season-score,
        #game-over.visible .button-container {
            transform: translateY(0);
            opacity: 1;
        }
        
        #home-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 0;
            box-sizing: border-box;
            pointer-events: auto;
            z-index: 5;
            background-color: rgba(0, 0, 0, 0.3); /* Légèrement transparent */
        }
        
        #game-title-container {
            text-align: center;
            margin-bottom: 50px;
            z-index: 6;
        }
        
        #game-button-container {
            text-align: center;
            margin-top: 50px;
            z-index: 6;
        }
        
        .button-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #game-title {
            font-size: 4.5rem;
            font-weight: bold;
            color: #FFFFFF;
            letter-spacing: 2px;
            text-shadow: 
                0 2px 0 rgba(0, 0, 0, 0.5),
                0 4px 0 rgba(0, 255, 157, 0.3),
                0 6px 10px rgba(0, 0, 0, 0.3);
            transform: perspective(500px) rotateX(10deg);
            margin-bottom: 10px;
        }
        
        #score-display {
            font-size: 4rem;
            margin-bottom: 10px;
            color: #00FF9D; /* Vert original */
            font-weight: bold;
        }
        
        #best-score {
            font-size: 1.8rem;
            margin-bottom: 30px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .game-button {
            padding: 12px 24px;
            font-size: 1.2rem;
            background: linear-gradient(135deg, #00FF9D 0%, #00B38B 70%, #009E7F 100%);
            color: #121212;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            margin: 10px 0;
            min-width: 150px;
            text-align: center;
            font-weight: bold;
            letter-spacing: 1px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            text-transform: uppercase;
        }
        
        .game-button:hover {
            background: linear-gradient(135deg, #00FFB3 0%, #00C49C 70%, #00AF8F 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
        }
        
        .game-button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .game-button.secondary {
            background: transparent;
            color: white;
            border: 2px solid white;
            box-shadow: none;
        }
        
        .game-button.secondary:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        
        /* Style pour le profil utilisateur */
        .user-profile {
            position: absolute;
            top: 20px;
            right: 20px;
            left: auto;
            display: flex;
            align-items: center;
            z-index: 10;
            flex-direction: row-reverse; /* Inverser l'ordre pour mettre l'avatar à droite */
        }
        
        .avatar-container {
            position: relative;
            width: 32px;
            height: 32px;
            margin-left: 6px;
            margin-right: 0;
        }
        
        .avatar-border {
            position: absolute;
            top: -1.5px;
            left: -1.5px;
            right: -1.5px;
            bottom: -1.5px;
            border: 2px solid #00FF9D;
            border-radius: 50%;
            box-sizing: border-box;
        }
        
        .avatar-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
        }
        
        .user-info {
            color: white;
            text-align: right; /* Aligner le texte à droite */
        }
        
        .username {
            font-size: 11px;
            font-weight: bold;
            margin: 0;
            margin-bottom: 2px; /* Espacement entre username et ID */
        }
        
        .user-id {
            font-size: 9px;
            color: #aaa;
            margin: 0;
        }
        
        /* Styles pour la page de paramètres */
        #settings-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: none;
            z-index: 100;
        }
        
        .android-scroll-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
        }
        
        .settings-content {
            padding: 20px;
            box-sizing: border-box;
            color: white;
            padding-bottom: 100px; /* Espace supplémentaire en bas pour faciliter le défilement */
        }
        
        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }
        
        .settings-title {
            font-size: 24px;
            font-weight: bold;
            color: white;
        }
        
        .close-button {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        
        .close-button:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        
        .close-icon {
            color: white;
            font-size: 20px;
        }
        
        .profile-card {
            background-color: rgba(30, 30, 30, 0.8);
            border-radius: 12px;
            padding: 15px;
            display: flex;
            align-items: center;
            margin-bottom: 30px;
        }
        
        .profile-avatar {
            width: 70px;
            height: 70px;
            border-radius: 12px;
            margin-right: 15px;
            position: relative;
            overflow: hidden;
        }
        
        .profile-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .profile-avatar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 2px solid #00FF9D;
            border-radius: 12px;
            box-sizing: border-box;
        }
        
        .profile-info {
            flex: 1;
        }
        
        .username-container {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .username-input {
            background-color: transparent;
            border: none;
            color: white;
            font-size: 18px;
            font-weight: bold;
            font-family: 'Orbitron', sans-serif;
            padding: 5px 0;
            width: calc(100% - 30px);
            outline: none;
        }
        
        .edit-icon {
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-left: 10px;
        }
        
        .user-id-display {
            font-size: 14px;
            color: #aaa;
        }
        
        .paypal-section {
            margin-bottom: 30px;
        }
        
        .section-title {
            font-size: 16px;
            color: white;
            margin-bottom: 15px;
        }
        
        .paypal-input {
            width: 100%;
            background-color: rgba(30, 30, 30, 0.8);
            border: none;
            border-radius: 8px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            padding: 12px 15px;
            box-sizing: border-box;
            margin-bottom: 15px;
            outline: none;
        }
        
        .input-container {
            position: relative;
            margin-bottom: 15px;
        }
        
        .input-edit-icon {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: white;
        }
        
        .description-text {
            font-size: 12px;
            color: #aaa;
            line-height: 1.5;
        }
        
        .avatars-section {
            margin-bottom: 30px;
            position: relative;
            z-index: 2;
            padding-bottom: 30px; /* Ajouter de l'espace en bas */
        }
        
        .avatars-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 15px;
            padding: 0 10px;
        }
        
        .avatar-item {
            position: relative;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            overflow: hidden;
            border: 2px solid #333;
            cursor: pointer;
            transition: all 0.2s ease;
            margin: 0 auto;
        }
        
        .avatar-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .avatar-item.selected {
            border: 2px solid #4CAF50;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.8);
        }
        
        .avatar-check {
            position: absolute;
            bottom: 0;
            right: 0;
            background-color: #4CAF50;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            opacity: 0;
        }
        
        .avatar-item.selected .avatar-check {
            opacity: 1;
        }
        
        /* Optimisation des images d'avatar */
        .preload-images {
            position: absolute;
            width: 0;
            height: 0;
            overflow: hidden;
            z-index: -1;
        }
        
        /* Styles pour le bouton de son */
        .sound-toggle {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 100;
            transition: all 0.2s ease;
        }
        
        .sound-toggle:hover {
            background-color: rgba(0, 0, 0, 0.7);
            transform: scale(1.1);
        }
        
        .sound-toggle svg {
            width: 24px;
            height: 24px;
        }
        
        .sound-toggle.muted .sound-on {
            display: none;
        }
        
        .sound-toggle:not(.muted) .sound-off {
            display: none;
        }
        
        /* Correction pour iOS */
        .avatars-wrapper {
            position: relative;
            padding-bottom: 60px; /* Espace supplémentaire en bas */
        }
        
        .ios-spacer {
            height: 60px; /* Espace supplémentaire pour éviter la zone noire */
            width: 100%;
        }
        
        /* Styles spécifiques pour les appareils Android */
        .android-device {
            -webkit-tap-highlight-color: transparent; /* Désactiver le surlignage au toucher sur Android */
        }
    </style>
</head>
<body>
    <div class="preload-images" id="preload-container"></div>
    <div class="container">
        <!-- Profil utilisateur -->
        <div class="user-profile" id="profile-button">
            <div class="avatar-container">
                <div class="avatar-border"></div>
                <img id="avatarImg" class="avatar-img" src="avatars/avatar_default.jpg" alt="Avatar">
            </div>
            <div class="user-info">
                <p id="username" class="username">Username</p>
                <p id="userId" class="user-id">0000000000</p>
            </div>
        </div>
        
        <canvas id="game-canvas"></canvas>
        
        <div id="home-screen">
            <div id="game-title-container">
                <div id="game-title">TiDash</div>
            </div>
            <div id="game-button-container">
                <button id="play-button" class="game-button">Tap to Start</button>
            </div>
            
            <!-- Bouton pour activer/désactiver le son -->
            <div id="sound-toggle" class="sound-toggle muted">
                <svg class="sound-on" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M14.5 8.5C14.5 8.5 16 9.57 16 12C16 14.43 14.5 15.5 14.5 15.5" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M18 5C18 5 21 7 21 12C21 17 18 19 18 19" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M3 10.5V13.5C3 14.6046 3.5 15.5 5 15.5C6.5 15.5 7 14.6046 7 13.5V10.5C7 9.39543 6.5 8.5 5 8.5C3.5 8.5 3 9.39543 3 10.5Z" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M7 10L11 7V17L7 14" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <svg class="sound-off" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M2 9L22 21" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M11 7L7 10H5C3.5 10 3 10.8954 3 12V12C3 13.1046 3.5 14 5 14H7L11 17V7Z" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M14.5 10.5C14.5 10.5 15.0049 10.7705 15.5 11.5" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M18 8C18 8 19.5 9.5 19.5 12" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </div>
        </div>
        <div id="game-over">
            <div id="score-display">0</div>
            <div id="best-score">Best: 0</div>
            <div id="season-score" style="font-size: 2.2rem; color: #00FF9D; font-weight: bold; margin-bottom: 20px;">Season Best: 0</div>
            <div class="button-container">
                <button id="play-again" class="game-button">PLAY AGAIN</button>
                <button id="home-button" class="game-button secondary">HOME</button>
            </div>
        </div>
        
        <!-- Page de paramètres -->
        <div id="settings-screen">
            <div class="android-scroll-container">
                <div class="settings-content">
                    <div class="settings-header">
                        <div class="settings-title">Settings</div>
                        <div class="close-button" id="close-settings">
                            <span class="close-icon">✕</span>
                        </div>
                    </div>
                    
                    <div class="profile-card">
                        <div class="profile-avatar">
                            <img id="settings-avatar" src="avatars/avatar_default.jpg" alt="Avatar">
                        </div>
                        <div class="profile-info">
                            <div class="username-container">
                                <input type="text" id="username-input" class="username-input" value="Username">
                                <div class="edit-icon">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M16.4745 5.40768L18.5917 7.52483M17.8358 3.54254L11.6002 9.77806C11.3979 9.98031 11.2619 10.2384 11.2104 10.5192L10.5798 13.4209L13.4816 12.7903C13.7624 12.7388 14.0205 12.6028 14.2227 12.4006L20.4582 6.16508C20.5844 6.03889 20.6846 5.88909 20.7536 5.72343C20.8226 5.55777 20.8589 5.37966 20.8605 5.19938C20.8621 5.01909 20.8289 4.84039 20.7628 4.6736C20.6967 4.50681 20.5991 4.35537 20.4749 4.22718C20.3507 4.09899 20.2022 3.99691 20.0374 3.92553C19.8726 3.85415 19.6951 3.81549 19.5157 3.81169C19.3364 3.8079 19.1574 3.83906 18.9899 3.90281C18.8224 3.96656 18.6698 4.06188 18.5401 4.18348L12.3046 10.419C12.1023 10.6212 11.9664 10.8793 11.9149 11.1601L11.2843 14.0619L14.186 13.4313C14.4668 13.3798 14.7249 13.2438 14.9272 13.0416L21.1627 6.80608C21.8106 6.15818 22.1655 5.28206 22.1529 4.36728C22.1403 3.45249 21.7612 2.58647 21.0961 1.9549C20.431 1.32333 19.5401 0.96993 18.6146 1.00182C17.689 1.03372 16.8179 1.44959 16.1974 2.12483L9.96196 8.36035C9.35302 8.96929 8.94371 9.74882 8.79747 10.5981L7.7655 15.2322C7.73328 15.3697 7.73471 15.5131 7.76969 15.6498C7.80467 15.7864 7.87221 15.9122 7.96643 16.0172C8.06066 16.1222 8.17871 16.2034 8.31082 16.2544C8.44293 16.3054 8.58559 16.3247 8.72856 16.3108L13.3627 15.2788C14.212 15.1326 14.9915 14.7233 15.6004 14.1143L21.8359 7.87877L16.4745 5.40768Z" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </div>
                        </div>
                        <div class="user-id-display">ID : <span id="settings-user-id">0000000000</span></div>
                    </div>
                </div>
                
                <div class="paypal-section">
                    <div class="section-title">Enter your PayPal email address</div>
                    <div class="input-container">
                        <input type="email" id="paypal-email" class="paypal-input" placeholder="mypaypal@email.com">
                        <div class="input-edit-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M16.4745 5.40768L18.5917 7.52483M17.8358 3.54254L11.6002 9.77806C11.3979 9.98031 11.2619 10.2384 11.2104 10.5192L10.5798 13.4209L13.4816 12.7903C13.7624 12.7388 14.0205 12.6028 14.2227 12.4006L20.4582 6.16508C20.5844 6.03889 20.6846 5.88909 20.7536 5.72343C20.8226 5.55777 20.8589 5.37966 20.8605 5.19938C20.8621 5.01909 20.8289 4.84039 20.7628 4.6736C20.6967 4.50681 20.5991 4.35537 20.4749 4.22718C20.3507 4.09899 20.2022 3.99691 20.0374 3.92553C19.8726 3.85415 19.6951 3.81549 19.5157 3.81169C19.3364 3.8079 19.1574 3.83906 18.9899 3.90281C18.8224 3.96656 18.6698 4.06188 18.5401 4.18348L12.3046 10.419C12.1023 10.6212 11.9664 10.8793 11.9149 11.1601L11.2843 14.0619L14.186 13.4313C14.4668 13.3798 14.7249 13.2438 14.9272 13.0416L21.1627 6.80608C21.8106 6.15818 22.1655 5.28206 22.1529 4.36728C22.1403 3.45249 21.7612 2.58647 21.0961 1.9549C20.431 1.32333 19.5401 0.96993 18.6146 1.00182C17.689 1.03372 16.8179 1.44959 16.1974 2.12483L9.96196 8.36035C9.35302 8.96929 8.94371 9.74882 8.79747 10.5981L7.7655 15.2322C7.73328 15.3697 7.73471 15.5131 7.76969 15.6498C7.80467 15.7864 7.87221 15.9122 7.96643 16.0172C8.06066 16.1222 8.17871 16.2034 8.31082 16.2544C8.44293 16.3054 8.58559 16.3247 8.72856 16.3108L13.3627 15.2788C14.212 15.1326 14.9915 14.7233 15.6004 14.1143L21.8359 7.87877L16.4745 5.40768Z" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </div>
                    </div>
                    <div class="description-text">
                        This is where your prize money will be sent if you win 1st place in the season ranking. Make sure your PayPal account is active and the email entered is correct, as this is how we will transfer your winnings!
                    </div>
                </div>
                
                <div class="avatars-section">
                    <div class="avatars-wrapper">
                        <div class="section-title">Select your avatar</div>
                        <div class="avatars-grid" id="avatars-grid">
                            <!-- Les avatars seront ajoutés dynamiquement ici -->
                        </div>
                        <div class="ios-spacer"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const tg = window.Telegram.WebApp;
        const gameOverScreen = document.getElementById('game-over');
        const homeScreen = document.getElementById('home-screen');
        const scoreDisplay = document.getElementById('score-display');
        const bestScoreDisplay = document.getElementById('best-score');
        const seasonScoreDisplay = document.getElementById('season-score');
        const playAgainBtn = document.getElementById('play-again');
        const homeBtn = document.getElementById('home-button');
        const playBtn = document.getElementById('play-button');

        // Désactiver le zoom sur mobile
        document.addEventListener('touchmove', function (event) {
            if (event.scale !== 1) {
                event.preventDefault();
            }
        }, { passive: false });
        
        // Double-tap prevention
        document.addEventListener('touchend', function(event) {
            const now = Date.now();
            const DOUBLE_TAP_THRESHOLD = 300;
            if (now - lastTouchEnd <= DOUBLE_TAP_THRESHOLD) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
        
        let lastTouchEnd = 0;

        // Game variables
        let gameRunning = false;
        let gameMode = 'home'; // 'home', 'game', 'gameOver'
        let score = 0;
        let bestScore = 0; // Sera initialisé correctement dans initUserProfile
        let seasonScore = 0; // Ajout d'une variable pour suivre le score de la saison en cours
        
        // Variables pour les étoiles
        let stars = [];
        const maxStars = 45; // Nombre d'étoiles
        
        // Variables pour le profil utilisateur
        let username = "";
        let userId = "";
        let avatarSrc = "/avatars/avatar_default.jpg";
        let paypalEmail = "";
        
        // Variables pour la musique de fond
        let homeMusics = [
            "home_musics/dont-talk-315229.mp3",
            "home_musics/Onchain.mp3",
            "home_musics/gardens-stylish-chill-303261.mp3",
            "home_musics/gorila-315977 (1).mp3",
            "home_musics/ClicClic.mp3",
            "home_musics/night-detective-226857.mp3"
        ];
        let currentMusicIndex = -1;
        let backgroundMusicElement = document.getElementById('backgroundMusic');
        
        // Variable pour suivre si la musique est en attente d'autoplay
        window.musicPendingAutoplay = true;
        
        // Variables pour gérer séparément la musique de fond et les effets sonores
        let isMusicEnabled = false; // Contrôle uniquement la musique de fond
        let isGameSoundEnabled = true; // Contrôle uniquement les effets sonores du jeu (toujours activés par défaut)
        let userPrefersMusicEnabled = false; // Changed from localStorage to variable
        
        // Variable pour suivre si la musique a déjà été activée par l'utilisateur
        let musicActivatedByUser = false;
        
        // Système audio optimisé pour mobile avec Web Audio API
        let audioContext;
        const audioBuffers = {};
        const audioSources = {};
        let audioInitialized = false;
        
        // Initialiser le système audio
        function initAudioSystem() {
            try {
                // Créer le contexte audio
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                audioContext = new AudioContext();
                
                // Précharger les sons
                preloadSounds();
                
                // Marquer comme initialisé
                audioInitialized = true;
                
                console.log("Système audio initialisé");
            } catch (error) {
                console.error("Erreur d'initialisation audio:", error);
                // Fallback à la méthode standard si Web Audio API n'est pas supportée
                audioInitialized = false;
            }
        }
        
        // Précharger les sons pour une lecture instantanée
        function preloadSounds() {
            const sounds = {
                'userTap': document.getElementById('userTapSound'),
                'success': document.getElementById('successSound'),
                'gameOver': document.getElementById('gameOverSound'),
                'showScore': document.getElementById('showScoreSound'),
                'borderTouch': document.getElementById('borderTouchSound')
            };
            
            // Pour chaque son
            for (const [name, audioElement] of Object.entries(sounds)) {
                if (!audioElement) continue;
                
                // Stocker l'élément audio pour le fallback
                audioSources[name] = audioElement;
                
                // Précharger avec Web Audio API
                if (audioContext) {
                    fetch(audioElement.src)
                        .then(response => response.arrayBuffer())
                        .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
                        .then(audioBuffer => {
                            audioBuffers[name] = audioBuffer;
                            console.log(`Son ${name} préchargé`);
                        })
                        .catch(error => {
                            console.error(`Erreur lors du préchargement du son ${name}:`, error);
                        });
                }
            }
        }
        
        // Jouer un son avec le moins de latence possible
        function playSound(name) {
            // Ne jouer les sons que si on est en mode jeu et si le son est activé
            if (gameMode !== 'game' && name === 'borderTouch') {
                return;
            }
            
            if (!isGameSoundEnabled) {
                return;
            }
            
            // Si le système audio n'est pas initialisé, l'initialiser
            if (!audioInitialized && typeof AudioContext !== 'undefined') {
                initAudioSystem();
            }
            
            try {
                // Si Web Audio API est disponible et le son est préchargé
                if (audioInitialized && audioContext && audioBuffers[name]) {
                    // Vérifier si le contexte est suspendu (restriction mobile)
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                    
                    // Créer une source sonore
                    const source = audioContext.createBufferSource();
                    source.buffer = audioBuffers[name];
                    
                    // Connecter à la sortie audio
                    source.connect(audioContext.destination);
                    
                    // Jouer immédiatement
                    source.start(0);
                    return;
                }
                
                // Fallback à la méthode standard
                if (audioSources[name]) {
                    const audio = audioSources[name];
                    audio.currentTime = 0;
                    
                    // Utiliser une promesse pour gérer la lecture
                    const playPromise = audio.play();
                    if (playPromise !== undefined) {
                        playPromise.catch(error => {
                            console.error(`Erreur de lecture audio (${name}):`, error);
                            
                            // Si l'erreur est liée à l'interaction utilisateur, initialiser le système audio
                            if (error.name === 'NotAllowedError') {
                                // On ne peut rien faire ici, il faut une interaction utilisateur
                                console.log("Interaction utilisateur requise pour la lecture audio");
                            }
                        });
                    }
                }
            } catch (error) {
                console.error(`Erreur lors de la lecture du son ${name}:`, error);
            }
        }
        
        // Activer l'audio sur interaction utilisateur
        function setupAudioActivation() {
            const activateAudio = () => {
                // Initialiser le système audio
                if (!audioInitialized) {
                    initAudioSystem();
                }
                
                // Jouer un son silencieux pour débloquer l'audio sur mobile
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log("Contexte audio repris");
                        
                        // Créer un oscillateur silencieux pour "réveiller" l'audio
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        gainNode.gain.value = 0; // Volume à 0
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        oscillator.start(0);
                        oscillator.stop(audioContext.currentTime + 0.001); // Jouer pendant 1ms
                    });
                }
                
                // Supprimer les écouteurs d'événements
                document.removeEventListener('click', activateAudio, true);
                document.removeEventListener('touchstart', activateAudio, true);
                document.removeEventListener('keydown', activateAudio, true);
            };
            
            // Ajouter les écouteurs d'événements
            document.addEventListener('click', activateAudio, true);
            document.addEventListener('touchstart', activateAudio, true);
            document.addEventListener('keydown', activateAudio, true);
        }
        
        let ball = {
            x: 0,
            y: 0,
            radius: 0,
            speed: 0,
            direction: 1 // 1 for right, -1 for left
        };
        let line = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        };
        let squares = [];
        let fadingSquares = []; // Squares that are fading out
        let particles = []; // Particles for ball explosion
        let gameOverAnimation = false;
        let gameOverAnimationComplete = false;
        let lastSquareTime = 0;
        let squareInterval = 1100; // Intervalle augmenté pour réduire la difficulté
        let lastFrameTime = 0;
        let greenSquareChance = 0.2; // 20% chance for green squares
        let lineProximityThreshold = 0; // Distance minimale entre les carrés et la ligne
        let canSpawnNewSquare = true; // Variable pour contrôler l'apparition des carrés

        // Return to home screen
        function goToHome() {
            gameMode = 'home';
            gameOverScreen.style.display = 'none';
            homeScreen.style.display = 'flex';
            gameOverAnimation = false;
            gameOverAnimationComplete = false;
            
            // Réafficher le profil utilisateur sur l'écran d'accueil
            document.getElementById("profile-button").style.display = 'flex';
            
            // Make sure the game loop is running for the home screen animation
            if (!gameRunning) {
                gameRunning = true;
                requestAnimationFrame(gameLoop);
            }
            
            // Gérer la musique de fond (démarrer sur l'écran d'accueil)
            manageBackgroundMusic();
        }

        // Initialize the game
        function initGame() {
            // Set canvas size to match container
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            // Initialize ball - larger radius
            ball.radius = canvas.width * 0.035;
            ball.y = canvas.height * 0.5; // Middle of the screen vertically
            ball.x = canvas.width / 2;
            ball.speed = canvas.width * 0.0008; // Slightly faster speed
            ball.direction = 1;
            
            // Initialize line - 80% of width and same height as ball
            line.width = canvas.width * 0.8;
            line.height = ball.radius * 2; // Same height as the ball diameter
            line.x = (canvas.width - line.width) / 2;
            line.y = ball.y - ball.radius; // Center the ball on the line
            
            // Initialiser les étoiles
            initStars();
            
            // Configurer l'activation audio
            setupAudioActivation();
            
            // Initialiser le profil utilisateur
            initUserProfile();
            
            // Envoyer les données utilisateur au serveur pour le panneau d'admin
            sendUserDataToServer();
            
            // Reset game state
            squares = [];
            fadingSquares = [];
            particles = [];
            gameOverAnimation = false;
            gameOverAnimationComplete = false;
            score = 0;
            
            // Start game loop if not already running
            if (!gameRunning) {
                gameRunning = true;
                requestAnimationFrame(gameLoop);
            }
        }
        
        // Initialiser les étoiles
        function initStars() {
            stars = [];
            for (let i = 0; i < maxStars; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 1.2 + 0.3, // Taille entre 0.3 et 1.5 pixels
                    opacity: Math.random() * 0.4 + 0.3, // Opacité entre 0.3 et 0.7 (augmentée pour plus de visibilité)
                    speed: Math.random() * 0.2 + 0.05, // Vitesse entre 0.05 et 0.25 pixels par frame
                    direction: Math.random() * Math.PI * 2 // Direction aléatoire en radians
                });
            }
        }
        
        // Dessiner les étoiles
        function drawStars() {
            // Ne dessiner les étoiles que sur l'écran d'accueil et pendant le jeu
            if (gameMode === 'home' || gameMode === 'game') {
                for (let i = 0; i < stars.length; i++) {
                    const star = stars[i];
                    
                    // Mise à jour de la position
                    star.x += Math.cos(star.direction) * star.speed;
                    star.y += Math.sin(star.direction) * star.speed;
                    
                    // Si l'étoile sort de l'écran, la replacer de l'autre côté
                    if (star.x < 0) star.x = canvas.width;
                    if (star.x > canvas.width) star.x = 0;
                    if (star.y < 0) star.y = canvas.height;
                    if (star.y > canvas.height) star.y = 0;
                    
                    // Dessiner l'étoile
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
                    ctx.fill();
                }
            }
        }

        // Start the actual gameplay
        function startGame() {
            // Hide home screen
            homeScreen.style.display = 'none';
            
            // Masquer le profil utilisateur pendant le jeu
            document.getElementById("profile-button").style.display = 'none';
            
            // Reset game state
            resetGame();
            
            // Réinitialiser les variables de jeu
            gameOverAnimation = false;
            gameOverAnimationComplete = false;
            
            // Set game mode to 'game'
            gameMode = 'game';
            
            // Gérer la musique de fond (arrêter pendant le jeu)
            manageBackgroundMusic();
            
            // Force restart game loop
            gameRunning = true;
            lastFrameTime = null;
            
            // Réinitialiser la position et la vitesse de la balle
            ball.x = canvas.width / 2;
            ball.y = canvas.height * 0.5;
            ball.direction = Math.random() > 0.5 ? 1 : -1;
            ball.speed = canvas.width * 0.0008;
            
            // Réinitialiser la position de la ligne
            line.x = (canvas.width - line.width) / 2;
            line.y = ball.y - ball.radius;
            
            // Démarrer la boucle de jeu
            requestAnimationFrame(gameLoop);
        }

        // Game loop
        function gameLoop(timestamp) {
            if (!lastFrameTime) lastFrameTime = timestamp;
            const deltaTime = timestamp - lastFrameTime;
            lastFrameTime = timestamp;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Dessiner les étoiles en arrière-plan
            drawStars();
            
            // Mettre à jour la position de la balle pour tous les modes
            if (gameMode !== 'gameOver' || !gameOverAnimation) {
                ball.x += ball.speed * ball.direction * deltaTime;
                
                // Check if ball hits the edge of the line
                if (ball.x - ball.radius < line.x) {
                    ball.x = line.x + ball.radius;
                    ball.direction = 1;
                    
                    // Only play border touch sound during gameplay, not on home screen
                    if (gameMode === 'game') {
                        playSound('borderTouch');
                    }
                } else if (ball.x + ball.radius > line.x + line.width) {
                    ball.x = line.x + line.width - ball.radius;
                    ball.direction = -1;
                    
                    // Only play border touch sound during gameplay, not on home screen
                    if (gameMode === 'game') {
                        playSound('borderTouch');
                    }
                }
            }
            
            // Always draw the line
            drawLine();
            
            // Ne dessiner la balle que si on n'est pas en animation de game over
            if (gameMode !== 'gameOver' || !gameOverAnimation) {
                drawBall();
            }
            
            if (gameMode === 'game' || gameMode === 'gameOver') {
                // Update and draw particles - Déplacer avant les carrés pour que les particules soient visibles
                updateParticles(deltaTime);
                
                // Update and draw squares
                updateSquares(deltaTime);
                
                // Update and draw fading squares
                updateFadingSquares(deltaTime);
                
                if (gameMode === 'game') {
                    // Check for collisions
                    if (checkCollisions()) {
                        return;
                    }
                    
                    // Spawn new squares
                    if ((squares.length === 0) || (squares.length > 0 && squares[squares.length-1].y > canvas.height * 0.20)) {
                        spawnSquare();
                        lastSquareTime = Date.now();
                        
                        // Gradually decrease spawn interval
                        if (squareInterval > 500) {
                            squareInterval -= 10;
                        }
                    }
                    
                    // Draw score
                    drawScore();
                }
            }
            
            // Continue the game loop
            if (gameRunning) {
                requestAnimationFrame(gameLoop);
            }
        }

        // Spawn a new square
        function spawnSquare() {
            // Larger squares
            const size = canvas.width * 0.07;
            
            // Make sure squares pass through the horizontal line
            // Calculate a position that will ensure the square passes through the line
            const lineCenter = line.x + line.width / 2;
            const lineWidth = line.width;
            
            // Random position that ensures passing through the line
            const minX = Math.max(0, line.x - size);
            const maxX = Math.min(canvas.width - size, line.x + line.width);
            const x = minX + Math.random() * (maxX - minX);
            
            const isGreen = Math.random() < greenSquareChance;
            
            // Random diagonal angle for falling, but ensure it passes through the line
            const targetX = line.x + Math.random() * line.width;
            const targetY = line.y;
            
            // Calculate angle to ensure it passes through the line
            const dx = targetX - (x + size/2);
            const dy = targetY - (-size/2);
            const angle = Math.atan2(dx, dy);
            
            // Limit the angle to prevent too horizontal trajectories
            const limitedAngle = Math.max(Math.min(angle, Math.PI/4), -Math.PI/4);
            
            squares.push({
                x: x,
                y: -size,
                size: size,
                speed: canvas.height * 0.0005, // Revenir à la vitesse originale
                isGreen: isGreen,
                rotation: 0,
                rotationSpeed: 0.01 * (Math.random() > 0.5 ? 1 : -1), // Vitesse de rotation fixe et modérée
                angle: limitedAngle,
                velocityX: Math.sin(limitedAngle),
                velocityY: Math.cos(limitedAngle)
            });
        }

        // Update squares positions
        function updateSquares(deltaTime) {
            // Update regular squares
            for (let i = squares.length - 1; i >= 0; i--) {
                const square = squares[i];
                
                if (!gameOverAnimation) {
                    // Move square diagonally
                    square.x += square.velocityX * square.speed * deltaTime;
                    square.y += square.velocityY * square.speed * deltaTime;
                }
                
                // Update rotation
                square.rotation += square.rotationSpeed * deltaTime;
                
                // Check if square has reached the bottom area (above score)
                const scoreAreaY = canvas.height * 0.7; // Position plus haute (70% au lieu de 80%)
                
                if (square.y > scoreAreaY && !gameOverAnimation) {
                    // Add to fading squares and remove from regular squares
                    square.fadeStartTime = Date.now();
                    square.fadeTime = 1500; // 1.5 seconds for fade animation
                    square.originalSize = square.size;
                    fadingSquares.push(square);
                    squares.splice(i, 1);
                    continue;
                }
                
                // Remove squares that are off-screen horizontally
                if ((square.x < -square.size || square.x > canvas.width) && !gameOverAnimation) {
                    squares.splice(i, 1);
                    continue;
                }
                
                // Draw rotating square
                ctx.save();
                ctx.translate(square.x + square.size/2, square.y + square.size/2);
                ctx.rotate(square.rotation);
                ctx.fillStyle = square.isGreen ? '#00FF9D' : '#FFFFFF'; // Couleur verte pour les carrés verts
                ctx.fillRect(-square.size/2, -square.size/2, square.size, square.size);
                ctx.restore();
            }
        }

        // Update fading squares
        function updateFadingSquares(deltaTime) {
            for (let i = fadingSquares.length - 1; i >= 0; i--) {
                const square = fadingSquares[i];
                
                // Calculate how much time has passed since fade started
                const fadeElapsed = Date.now() - square.fadeStartTime;
                const fadeProgress = Math.min(fadeElapsed / square.fadeTime, 1);
                
                // Update rotation (continue rotating while fading)
                square.rotation += square.rotationSpeed * deltaTime;
                
                // Calculate new size based on fade progress (shrink to nothing)
                const newSize = square.originalSize * (1 - fadeProgress);
                
                // Remove if fade is complete
                if (fadeProgress >= 1) {
                    fadingSquares.splice(i, 1);
                    continue;
                }
                
                // Draw fading square
                ctx.save();
                ctx.translate(square.x + square.originalSize/2, square.y + square.originalSize/2);
                ctx.rotate(square.rotation);
                ctx.fillStyle = square.isGreen ? '#00FF9D' : '#FFFFFF'; // Couleur verte pour les carrés verts
                ctx.globalAlpha = 1 - fadeProgress; // Also fade opacity
                ctx.fillRect(-newSize/2, -newSize/2, newSize, newSize);
                ctx.globalAlpha = 1;
                ctx.restore();
            }
        }

        // Create explosion particles from the ball
        function createExplosion(x, y, color) {
            const particleCount = 120; // Augmenter légèrement le nombre de particules
            const particleSize = ball.radius / 4; // Particules plus fines (divisé par 4 au lieu de 2)
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 8 + 3; // Vitesse plus élevée
                const distance = Math.random() * ball.radius;
                
                particles.push({
                    x: x + Math.cos(angle) * distance,
                    y: y + Math.sin(angle) * distance,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: particleSize * (Math.random() * 0.5 + 0.3), // Particules plus fines
                    color: color || '#00FF9D',
                    alpha: 1,
                    fadeSpeed: 0.01 + Math.random() * 0.02 // Ralentir la disparition
                });
            }
        }

        // Update and draw particles
        function updateParticles(deltaTime) {
            // Si aucune particule, ne rien faire
            if (particles.length === 0) return;
            
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                // Update position - augmenter la vitesse de déplacement
                particle.x += particle.vx * deltaTime * 0.1;
                particle.y += particle.vy * deltaTime * 0.1;
                
                // Update alpha - ralentir la disparition
                particle.alpha -= particle.fadeSpeed * deltaTime * 0.03;
                
                // Remove faded particles
                if (particle.alpha <= 0) {
                    particles.splice(i, 1);
                    continue;
                }
                
                // Draw particle
                ctx.save();
                ctx.globalAlpha = particle.alpha;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.restore();
            }
            
            // Check if all particles are gone
            if (particles.length === 0 && fadingSquares.length === 0 && gameOverAnimation) {
                gameOverAnimationComplete = true;
            }
        }

        // Draw the ball
        function drawBall() {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#00FF9D'; // Vert original
            ctx.fill();
            ctx.closePath();
        }

        // Draw the line
        function drawLine() {
            // Draw the actual line with rounded corners
            ctx.fillStyle = '#333333';
            
            // Use rounded rectangle
            const radius = line.height / 2;
            ctx.beginPath();
            ctx.moveTo(line.x + radius, line.y);
            ctx.lineTo(line.x + line.width - radius, line.y);
            ctx.arcTo(line.x + line.width, line.y, line.x + line.width, line.y + radius, radius);
            ctx.lineTo(line.x + line.width, line.y + line.height - radius);
            ctx.arcTo(line.x + line.width, line.y + line.height, line.x + line.width - radius, line.y + line.height, radius);
            ctx.lineTo(line.x + radius, line.y + line.height);
            ctx.arcTo(line.x, line.y + line.height, line.x, line.y + line.height - radius, radius);
            ctx.lineTo(line.x, line.y + radius);
            ctx.arcTo(line.x, line.y, line.x + radius, line.y, radius);
            ctx.closePath();
            ctx.fill();
        }
        
        // Draw score at the bottom
        function drawScore() {
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold ' + (canvas.width * 0.2) + 'px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(score.toString(), canvas.width / 2, canvas.height * 0.85);
        }

        // Check for collisions between ball and squares
        function checkCollisions() {
            for (let i = 0; i < squares.length; i++) {
                const square = squares[i];
                
                // Calculate distance between ball and square center
                const dx = ball.x - (square.x + square.size / 2);
                const dy = ball.y - (square.y + square.size / 2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Check if ball collides with square
                if (distance < ball.radius + square.size / 2) {
                    // If it's a green square, collect it
                    if (square.isGreen) {
                        // Jouer le son quand la balle touche un carré vert
                        playSound('success');
                        
                        // Remove the square
                        squares.splice(i, 1);
                        
                        // Increment score
                        score++;
                        
                        // Update season score if current score is better
                        if (score > seasonScore) {
                            seasonScore = score;
                            console.log(`🏆 New season best: ${seasonScore}`);
                        }
                        
                        // Update best score if needed
                        if (score > bestScore) {
                            bestScore = score;
                            console.log(`🌟 New all-time best: ${bestScore}`);
                        }
                        
                        // Create explosion effect
                        createExplosion(square.x + square.size / 2, square.y + square.size / 2, '#00FF9D');
                        
                        // Send the updated score to the server immediately
                        sendUserDataToServer();
                        
                        return false;
                    } else {
                        // Game over if it's a white square
                        // Jouer le son quand la balle touche un carré blanc
                        playSound('gameOver');
                        
                        // Create explosion effect
                        createExplosion(ball.x, ball.y, '#00FF9D');
                        
                        // Set game over mode
                        gameMode = 'gameOver';
                        gameOverAnimation = true;
                        
                        // Afficher l'écran de game over avec un court délai
                        setTimeout(() => {
                            showGameOverScreen();
                        }, 300); // Délai de 300ms
                        
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Function to show game over screen
        function showGameOverScreen() {
            // Jouer le son quand le popup de score s'affiche
            playSound('showScore');
            
            // Update score display
            document.getElementById('score-display').textContent = score;
            document.getElementById('best-score').textContent = `Best: ${bestScore}`;
            
            // CRITICAL FIX: Handle season score correctly on game over
            const seasonScoreElement = document.getElementById('season-score');
            if (seasonScoreElement) {
                // Vérifier s'il y a une saison active
                fetch('/api/seasons/active')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Error retrieving active season');
                    }
                    return response.json();
                })
                .then(data => {
                    if (data && data.id) {
                        console.log(`🔍 Active season found: ${data.id}, Season ${data.seasonNumber}`);
                        
                        fetch(`/api/seasons/${data.id}/scores/${userId}`)
                        .then(response => response.ok ? response.json() : { score: 0 })
                        .then(serverData => {
                            // Use the server's score as the source of truth
                            let serverSeasonBest = serverData && serverData.score ? parseInt(serverData.score) : 0;
                            
                            console.log(`🎮 Game Over - Current game score: ${score}, Server season best: ${serverSeasonBest}`);
                            
                            // IMPORTANT FIX: Always check if we need to update the season score
                            // We need to handle two cases:
                            // 1. If this is the first game in a new season, we should send the score regardless
                            // 2. If the current score is better than the stored season best
                            
                            // Check with the server if this is a new season for the user
                            const isFirstGame = serverSeasonBest === 0;
                            
                            if (isFirstGame || score > serverSeasonBest) {
                                // Update our local variable
                                if (score > serverSeasonBest) {
                                    seasonScore = score;
                                    console.log(`🏆 New season best achieved: ${seasonScore}`);
                                } else {
                                    console.log(`📊 First game in new season: ${score}`);
                                    // Even if it's not a personal best, we need to record it for the first game
                                    seasonScore = score;
                                }
                                
                                // Send updated score to server immediately
                                sendUserDataToServer();
                            } else {
                                // If we didn't update the score, make sure we're using the server's value
                                seasonScore = serverSeasonBest;
                            }
                            
                            // CRITICAL FIX: Always display the season score, regardless of whether it was updated
                            // This ensures the season score is always visible in the game over popup
                            seasonScoreElement.textContent = `Season ${data.seasonNumber} Best: ${seasonScore} 🏆`;
                            seasonScoreElement.style.display = 'block';
                        })
                        .catch(error => {
                            console.error('❌ Error getting season score from server:', error);
                            // Fallback to local data if server request fails
                            seasonScoreElement.textContent = `Season ${data.seasonNumber} Best: ${score} 🏆`;
                            seasonScoreElement.style.display = 'block';
                        });
                    } else {
                        seasonScoreElement.style.display = 'none';
                    }
                })
                .catch(error => {
                    console.error('❌ Error checking active season:', error);
                    seasonScoreElement.style.display = 'none';
                });
            }
            
            // Mettre à jour le mode de jeu
            gameMode = 'gameOver';
            
            // Gérer la musique de fond (arrêter pendant le game over)
            manageBackgroundMusic();
            
            // Afficher l'écran de game over
            const gameOverScreen = document.getElementById('game-over');
            gameOverScreen.style.display = 'flex';
            
            // Forcer un reflow pour que la transition fonctionne
            void gameOverScreen.offsetWidth;
            
            // Ajouter la classe visible pour déclencher l'animation
            gameOverScreen.classList.add('visible');
            console.log("Game over screen displayed");
        }
        
        // Function to hide game over screen
        function hideGameOver() {
            // Masquer immédiatement l'écran de game over sans animation
            gameOverScreen.style.display = 'none';
            // Réinitialiser la classe visible pour les futures utilisations
            gameOverScreen.classList.remove('visible');
        }

        // Function to reset the game and start a new game
        function resetGame() {
            // Hide game over screen
            hideGameOver();
            
            // Reset game state
            squares = [];
            fadingSquares = [];
            particles = [];
            gameOverAnimation = false;
            gameOverAnimationComplete = false;
            score = 0;
            
            // Update game mode
            gameMode = 'game';
            
            // Reset ball position and speed
            ball.x = canvas.width / 2;
            ball.y = canvas.height * 0.5;
            ball.direction = Math.random() > 0.5 ? 1 : -1;
            ball.speed = canvas.width * 0.0008;
            
            // Reset line position
            line.x = (canvas.width - line.width) / 2;
            line.y = ball.y - ball.radius;
            
            // Hide profile button during gameplay
            document.getElementById("profile-button").style.display = 'none';
            
            // Manage background music for game mode
            manageBackgroundMusic();
            
            // Make sure game loop is running
            if (!gameRunning) {
                gameRunning = true;
                lastFrameTime = null;
                requestAnimationFrame(gameLoop);
            }
            
            // Play sound effect
            playSound('userTap');
        }

        // Handle screen tap/click
        function handleTap() {
            if (gameMode === 'game') {
                // Change ball direction
                ball.direction *= -1;
                
                // Jouer le son quand l'utilisateur touche l'écran
                playSound('userTap');
            }
        }

        // Resize handler
        function resizeCanvas() {
            // Set canvas size to match container
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            // Adjust ball size based on canvas width
            ball.radius = canvas.width * 0.035;
            
            // Adjust line dimensions
            line.width = canvas.width * 0.8;
            line.height = ball.radius * 2;
            
            // Reposition ball and line
            if (gameMode === 'home') {
                // On home screen, position in the middle
                ball.x = canvas.width / 2;
                ball.y = canvas.height * 0.5;
                line.x = (canvas.width - line.width) / 2;
                line.y = ball.y - ball.radius;
            }
            
            // Redraw stars for new dimensions
            initStars();
            
            console.log(`📱 Canvas resized to ${canvas.width}x${canvas.height}`);
        }

        // Handle window resize
        function handleResize() {
            // Delay resize to avoid performance issues during resize
            clearTimeout(window.resizeTimer);
            window.resizeTimer = setTimeout(function() {
                resizeCanvas();
            }, 250);
        }

        // Add resize event listener
        window.addEventListener('resize', handleResize);

        // Event listeners
        canvas.addEventListener('click', handleTap);
        
        // Handle play again button click
        playAgainBtn.addEventListener('click', resetGame);

        playBtn.addEventListener('click', startGame);

        // Générer un nom d'utilisateur aléatoire
        function generateRandomUsername() {
            const adjectives = [
                "Cosmic", "Stellar", "Quantum", "Neon", "Cyber", 
                "Digital", "Pixel", "Techno", "Hyper", "Mega", 
                "Ultra", "Retro", "Future", "Laser", "Plasma", 
                "Crystal", "Glitch", "Vector", "Synth", "Astro"
            ];
            
            const nouns = [
                "Runner", "Racer", "Dasher", "Pilot", "Navigator", 
                "Explorer", "Voyager", "Jumper", "Drifter", "Surfer", 
                "Rider", "Hunter", "Ninja", "Warrior", "Knight", 
                "Wizard", "Hacker", "Gamer", "Player", "Master"
            ];
            
            const randomAdjective = adjectives[Math.floor(Math.random() * adjectives.length)];
            const randomNoun = nouns[Math.floor(Math.random() * nouns.length)];
            
            return randomAdjective + randomNoun;
        }
        
        // Générer un ID à 10 chiffres
        function generateRandomUserId() {
            let id = "";
            for (let i = 0; i < 10; i++) {
                id += Math.floor(Math.random() * 10);
            }
            return id;
        }
        
        // Sélectionner un avatar aléatoire
        function getRandomAvatar() {
            return "/avatars/avatar_default.jpg";
        }
        
        // Initialiser ou récupérer le profil utilisateur
        function initUserProfile() {
            try {
                console.log("🧑 Initializing user profile...");
                
                // Try to get a device identifier or generate a new one
                let deviceId = getCookie("tidashDeviceId");
                if (!deviceId) {
                    deviceId = generateRandomUserId();
                    setCookie("tidashDeviceId", deviceId, 365); // Store for 1 year
                    console.log(`🆕 Generated new device ID: ${deviceId}`);
                } else {
                    console.log(`🔍 Found existing device ID: ${deviceId}`);
                }
                
                // Fetch user data from server using device ID
                fetch(`/api/users/device/${deviceId}`)
                    .then(response => {
                        if (response.status === 404) {
                            console.log("👤 User not found, creating new profile");
                            
                            // Generate random username and ID if not found
                            username = generateRandomUsername();
                            userId = generateRandomUserId();
                            avatarSrc = "/avatars/avatar_default.jpg";
                            bestScore = 0;
                            seasonScore = 0;
                            
                            // Create new user with device ID
                            const userData = {
                                gameId: userId,
                                gameUsername: username,
                                deviceId: deviceId,
                                avatarSrc: '/avatars/avatar_default.jpg',
                                bestScore: 0,
                                seasonScore: 0,
                                musicEnabled: true
                            };
                            
                            console.log("📝 Creating new user:", userData);
                            
                            // Send new user data to server
                            return fetch('/api/users', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify(userData)
                            })
                            .then(response => {
                                if (!response.ok) {
                                    throw new Error('Failed to create user');
                                }
                                return response.json();
                            })
                            .then(data => {
                                console.log("✅ New user created:", data);
                                
                                // Update UI
                                updateUserProfileDisplay();
                                updateScoreDisplay();
                                updateSoundToggleDisplay();
                                
                                return null; // Return null to indicate we've handled this case
                            });
                        } else if (!response.ok) {
                            throw new Error('Failed to fetch user data');
                        } else {
                            return response.json();
                        }
                    })
                    .then(data => {
                        if (data) {
                            console.log("✅ User data loaded from server:", data);
                            
                            // Check if user has a gameId and gameUsername
                            let needsUpdate = false;
                            
                            // Set user data from server response
                            if (!data.gameId) {
                                userId = generateRandomUserId();
                                needsUpdate = true;
                                console.log("🆕 Generated new game ID for existing user:", userId);
                            } else {
                                userId = data.gameId;
                            }
                            
                            if (!data.gameUsername) {
                                username = generateRandomUsername();
                                needsUpdate = true;
                                console.log("🆕 Generated new username for existing user:", username);
                            } else {
                                username = data.gameUsername;
                            }
                            
                            // Handle avatar path correctly
                            if (data.avatarSrc) {
                                // Ensure avatar path is absolute
                                if (data.avatarSrc.startsWith('http')) {
                                    avatarSrc = data.avatarSrc;
                                } else if (data.avatarSrc.startsWith('/')) {
                                    avatarSrc = window.location.origin + data.avatarSrc;
                                } else {
                                    avatarSrc = window.location.origin + '/avatars/' + data.avatarSrc;
                                }
                            } else {
                                // Default avatar with absolute path
                                avatarSrc = window.location.origin + '/avatars/avatar_default.jpg';
                            }
                            
                            paypalEmail = data.paypalEmail || "";
                            bestScore = parseInt(data.bestScore || "0");
                            
                            // Set music preference from server
                            isMusicEnabled = data.musicEnabled !== undefined ? data.musicEnabled : true;
                            
                            // If we generated a new ID or username, update the user data on the server
                            if (needsUpdate) {
                                console.log("🔄 Updating user with new ID or username");
                                setTimeout(() => sendUserDataToServer(), 500);
                            }
                            
                            // Update UI elements
                            updateUserProfileDisplay();
                            updateScoreDisplay();
                            updateSoundToggleDisplay();
                        }
                        
                        // Initialize avatar selection
                        initAvatarSelection();
                        
                        // Check for new season
                        setTimeout(function() {
                            checkForNewSeason(true);
                        }, 1000);
                    })
                    .catch(error => {
                        console.error('❌ Error in user profile initialization:', error);
                        
                        // Fallback to creating a new user if fetch fails
                        username = generateRandomUsername();
                        userId = generateRandomUserId();
                        avatarSrc = window.location.origin + '/avatars/avatar_default.jpg';
                        bestScore = 0;
                        seasonScore = 0;
                        
                        console.log("🔄 Falling back to local user creation due to error");
                        
                        // Update UI elements
                        updateUserProfileDisplay();
                        updateScoreDisplay();
                        
                        // Try to send user data to server as a fallback
                        sendUserDataToServer();
                        
                        // Initialize avatar selection
                        initAvatarSelection();
                    });
            } catch (error) {
                console.error("❌ Error in initUserProfile:", error);
                
                // Emergency fallback
                username = generateRandomUsername();
                userId = generateRandomUserId();
                avatarSrc = window.location.origin + '/avatars/avatar_default.jpg';
                
                // Update UI as a last resort
                updateUserProfileDisplay();
            }
        }
        
        // Function to populate the avatar grid
        function populateAvatarGrid() {
            try {
                console.log("🖼️ Populating avatar grid...");
                const avatarsGrid = document.getElementById('avatars-grid');
                
                // Clear existing avatars
                avatarsGrid.innerHTML = '';
                
                // List of available avatars (using the correct filenames)
                const avatars = [
                    'avatar_default.jpg',
                    'avatar1.jpg',
                    'avatar2.jpg',
                    'avatar3.jpg',
                    'avatar4.jpg',
                    'avatar5.jpg',
                    'avatar6.jpg',
                    'avatar7.jpg',
                    'avatar8.jpg',
                    'avatar9.jpg',
                    'avatar10.jpg',
                    'avatar11.jpg',
                    'avatar12.jpg',
                    'avatar13.jpg',
                    'avatar14.jpg',
                    'avatar15.jpg',
                    'avatar16.jpg',
                    'avatar17.jpg',
                    'avatar18.jpg',
                    'avatar19.jpg',
                    'avatar20.jpg'
                ];
                
                // Create avatar items
                avatars.forEach(avatar => {
                    const avatarItem = document.createElement('div');
                    avatarItem.className = 'avatar-item';
                    
                    const img = document.createElement('img');
                    img.src = `avatars/${avatar}`;
                    img.alt = 'Avatar';
                    
                    const check = document.createElement('div');
                    check.className = 'avatar-check';
                    check.innerHTML = '✓';
                    
                    avatarItem.appendChild(img);
                    avatarItem.appendChild(check);
                    avatarsGrid.appendChild(avatarItem);
                });
                
                console.log(`✅ Added ${avatars.length} avatars to the grid`);
                
                // Initialize avatar selection
                initAvatarSelection();
            } catch (error) {
                console.error("❌ Error populating avatar grid:", error);
            }
        }

        // Function to initialize avatar selection
        function initAvatarSelection() {
            try {
                console.log("🖼️ Initializing avatar selection...");
                
                // Get all avatar items
                const avatarItems = document.querySelectorAll('.avatar-item');
                
                // Clear any existing selected state
                avatarItems.forEach(item => {
                    item.classList.remove('selected');
                });
                
                // Get current avatar filename
                const currentAvatarSrc = avatarSrc;
                const avatarFilename = currentAvatarSrc.split('/').pop();
                
                console.log(`🔍 Looking for avatar: ${avatarFilename}`);
                
                // Find and select the matching avatar
                let found = false;
                avatarItems.forEach(item => {
                    const itemImg = item.querySelector('img');
                    if (itemImg && itemImg.src.includes(avatarFilename)) {
                        item.classList.add('selected');
                        found = true;
                        console.log(`✅ Selected avatar: ${itemImg.src}`);
                    }
                });
                
                if (!found) {
                    console.log("⚠️ Matching avatar not found, selecting default");
                    // Select default avatar if no match found
                    const defaultAvatar = document.querySelector('.avatar-item:first-child');
                    if (defaultAvatar) {
                        defaultAvatar.classList.add('selected');
                    }
                }
                
                // Add click event listeners to avatar items
                avatarItems.forEach(item => {
                    item.addEventListener('click', function() {
                        // Remove selected class from all avatars
                        avatarItems.forEach(avatar => {
                            avatar.classList.remove('selected');
                        });
                        
                        // Add selected class to clicked avatar
                        this.classList.add('selected');
                        
                        // Get the src of the selected avatar
                        const selectedAvatarSrc = this.querySelector('img').src;
                        const avatarPath = '/avatars/' + selectedAvatarSrc.split('/').pop();
                        
                        // Update avatar in UI
                        document.getElementById('settings-avatar').src = selectedAvatarSrc;
                        document.getElementById('avatarImg').src = selectedAvatarSrc;
                        
                        // Update avatarSrc variable
                        avatarSrc = selectedAvatarSrc;
                        
                        // Save to server
                        sendUserDataToServer();
                        
                        console.log(`🖼️ Avatar updated: ${avatarPath}`);
                    });
                });
            } catch (error) {
                console.error("❌ Error initializing avatar selection:", error);
            }
        }
        
        // Function to update sound toggle display
        function updateSoundToggleDisplay() {
            try {
                const soundToggle = document.querySelector('.sound-toggle');
                if (soundToggle) {
                    if (isMusicEnabled) {
                        soundToggle.classList.remove('muted');
                    } else {
                        soundToggle.classList.add('muted');
                    }
                }
            } catch (error) {
                console.error("❌ Error updating sound toggle display:", error);
            }
        }
        
        // Function to send user data to server
        function sendUserDataToServer() {
            try {
                console.log("📤 Sending user data to server...");
                
                // Get device ID from cookie
                const deviceId = getCookie("tidashDeviceId") || "";
                
                // Get Telegram data if available
                const telegramId = window.telegramId || "";
                const telegramUsername = window.telegramUsername || "";
                
                // Prepare user data
                const userData = {
                    gameId: userId,
                    gameUsername: username,
                    bestScore: bestScore,
                    seasonScore: seasonScore,
                    avatarSrc: avatarSrc.includes('/avatars/') ? 
                        '/avatars/' + avatarSrc.split('/avatars/').pop() : 
                        avatarSrc,
                    paypalEmail: paypalEmail,
                    deviceId: deviceId,
                    musicEnabled: isMusicEnabled,
                    telegramId: telegramId,
                    telegramUsername: telegramUsername
                };
                
                console.log("📋 User data to send:", userData);
                
                // Send data to server
                return fetch('/api/users', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(userData)
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to save user data');
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('✅ User data saved successfully:', data);
                    
                    // Update user data from response if available
                    if (data.user) {
                        userId = data.user.gameId || userId;
                        bestScore = parseInt(data.user.bestScore || bestScore);
                        
                        // Update UI
                        updateUserProfileDisplay();
                        updateScoreDisplay();
                    }
                    
                    return data;
                })
                .catch(error => {
                    console.error('❌ Error saving user data:', error);
                });
            } catch (error) {
                console.error("❌ Error in sendUserDataToServer:", error);
            }
        }
        
        // Function to check for new season
        function checkForNewSeason(forceReset = false) {
            try {
                console.log("🔍 Checking for active season...");
                
                fetch('/api/seasons/active')
                .then(response => {
                    if (!response.ok) {
                        if (response.status === 404) {
                            return null;
                        }
                        throw new Error('Error retrieving active season');
                    }
                    return response.json();
                })
                .then(data => {
                    if (!data) {
                        // No active season, reset season score
                        seasonScore = 0;
                        updateScoreDisplay();
                        return;
                    }
                    
                    console.log(`✅ Active season found: ${data.id}, Season ${data.seasonNumber}`);
                    
                    // Get user's score for this season
                    return fetch(`/api/seasons/${data.id}/scores/${userId}`)
                    .then(response => response.ok ? response.json() : { score: 0 })
                    .then(serverData => {
                        // Use the server's score as the source of truth
                        let serverSeasonBest = serverData && serverData.score ? parseInt(serverData.score) : 0;
                        
                        console.log(`🎮 Game Over - Current game score: ${score}, Server season best: ${serverSeasonBest}`);
                        
                        // IMPORTANT FIX: Always check if we need to update the season score
                        // We need to handle two cases:
                        // 1. If this is the first game in a new season, we should send the score regardless
                        // 2. If the current score is better than the stored season best
                        
                        // Check with the server if this is a new season for the user
                        const isFirstGame = serverSeasonBest === 0;
                        
                        if (isFirstGame || score > serverSeasonBest) {
                            // Update our local variable
                            if (score > serverSeasonBest) {
                                seasonScore = score;
                                console.log(`🏆 New season best achieved: ${seasonScore}`);
                            } else {
                                console.log(`📊 First game in new season: ${score}`);
                                // Even if it's not a personal best, we need to record it for the first game
                                seasonScore = score;
                            }
                            
                            // Send updated score to server immediately
                            sendUserDataToServer();
                        } else {
                            // If we didn't update the score, make sure we're using the server's value
                            seasonScore = serverSeasonBest;
                        }
                        
                        // CRITICAL FIX: Always display the season score, regardless of whether it was updated
                        // This ensures the season score is always visible in the game over popup
                        const seasonScoreElement = document.getElementById('season-score');
                        if (seasonScoreElement) {
                            seasonScoreElement.textContent = `Season ${data.seasonNumber} Best: ${seasonScore} 🏆`;
                            seasonScoreElement.style.display = 'block';
                        }
                    })
                    .catch(error => {
                        console.error('❌ Error getting season score from server:', error);
                        // Fallback to local data if server request fails
                        const seasonScoreElement = document.getElementById('season-score');
                        if (seasonScoreElement) {
                            seasonScoreElement.textContent = `Season ${data.seasonNumber} Best: ${score} 🏆`;
                            seasonScoreElement.style.display = 'block';
                        }
                    });
                })
                .catch(error => {
                    console.error('❌ Error checking active season:', error);
                    const seasonScoreElement = document.getElementById('season-score');
                    if (seasonScoreElement) {
                        seasonScoreElement.style.display = 'none';
                    }
                });
            } catch (error) {
                console.error("❌ Error in checkForNewSeason:", error);
            }
        }
        
        // Helper function to get cookie value
        function getCookie(name) {
            const value = `; ${document.cookie}`;
            const parts = value.split(`; ${name}=`);
            if (parts.length === 2) return parts.pop().split(';').shift();
            return null;
        }
        
        // Helper function to set cookie
        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (value || "") + expires + "; path=/; SameSite=Strict";
        }
        
        // Function to update user profile display
        function updateUserProfileDisplay() {
            try {
                // Update username
                document.getElementById('username').textContent = username;
                
                // Update user ID
                document.getElementById('userId').textContent = userId;
                
                // Update avatar
                document.getElementById('avatarImg').src = avatarSrc;
                document.getElementById('settings-avatar').src = avatarSrc;
                
                // Update settings fields
                const usernameInput = document.getElementById('username-input');
                if (usernameInput) {
                    usernameInput.value = username;
                    usernameInput.placeholder = username;
                }
                
                const paypalInput = document.getElementById('paypal-email');
                if (paypalInput) {
                    paypalInput.value = paypalEmail || '';
                    paypalInput.placeholder = paypalEmail || 'mypaypal@email.com';
                }
                
                const settingsUserId = document.getElementById('settings-user-id');
                if (settingsUserId) {
                    settingsUserId.textContent = userId;
                }
            } catch (error) {
                console.error("❌ Error updating user profile display:", error);
            }
        }
        
        // Function to update score display
        function updateScoreDisplay() {
            try {
                // Update best score
                document.getElementById('best-score').textContent = `Best: ${bestScore}`;
                
                // Update season score
                const seasonScoreElement = document.getElementById('season-score');
                if (seasonScoreElement) {
                    seasonScoreElement.textContent = `Season Best: ${seasonScore} 🏆`;
                }
            } catch (error) {
                console.error("❌ Error updating score display:", error);
            }
        }
        
        // Initialize the game
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize canvas dimensions
            resizeCanvas();
            
            // Initialize stars
            initStars();
            
            // Populate avatar grid
            populateAvatarGrid();
            
            // Initialize Telegram WebApp if available
            if (window.Telegram && window.Telegram.WebApp) {
                console.log("📱 Telegram WebApp detected, initializing...");
                try {
                    const tgWebApp = window.Telegram.WebApp;
                    
                    // Check if we have user data directly from the WebApp
                    if (tgWebApp.initDataUnsafe && tgWebApp.initDataUnsafe.user) {
                        const tgUser = tgWebApp.initDataUnsafe.user;
                        console.log("👤 Telegram user data from WebApp:", tgUser);
                        
                        // Store Telegram user data for later use
                        window.telegramId = tgUser.id?.toString() || "";
                        window.telegramUsername = tgUser.username || "";
                        
                        console.log(`✅ Telegram ID: ${window.telegramId}, Username: ${window.telegramUsername}`);
                    } else {
                        // Fallback to parsing initData string
                        const tgData = tgWebApp.initData || "";
                        if (tgData) {
                            console.log("🔍 Parsing Telegram initData string");
                            try {
                                // Parse the initData to get user information
                                const urlParams = new URLSearchParams(tgData);
                                const userParam = urlParams.get('user');
                                if (userParam) {
                                    const tgUser = JSON.parse(decodeURIComponent(userParam));
                                    console.log("👤 Telegram user data from initData:", tgUser);
                                    
                                    // Store Telegram user data for later use
                                    window.telegramId = tgUser.id?.toString() || "";
                                    window.telegramUsername = tgUser.username || "";
                                    
                                    console.log(`✅ Telegram ID: ${window.telegramId}, Username: ${window.telegramUsername}`);
                                }
                            } catch (parseError) {
                                console.error("❌ Error parsing Telegram initData:", parseError);
                            }
                        }
                    }
                    
                    // Set up Telegram WebApp event handlers
                    tgWebApp.onEvent('viewportChanged', function() {
                        console.log("📱 Telegram viewport changed, resizing canvas...");
                        resizeCanvas();
                    });
                    
                    // Expand the WebApp to its maximum size
                    tgWebApp.expand();
                } catch (error) {
                    console.error("❌ Error initializing Telegram WebApp:", error);
                }
            }
            
            // Load user profile
            initUserProfile();
            
            // Envoyer les données utilisateur au serveur pour le panneau d'admin
            sendUserDataToServer();
            
            // Setup sound toggle
            const soundToggle = document.querySelector('.sound-toggle');
            if (soundToggle) {
                soundToggle.addEventListener('click', function() {
                    // Toggle music state
                    isMusicEnabled = !isMusicEnabled;
                    
                    // Update UI
                    if (isMusicEnabled) {
                        soundToggle.classList.remove('muted');
                        playBackgroundMusic();
                    } else {
                        soundToggle.classList.add('muted');
                        stopBackgroundMusic();
                    }
                    
                    // Save preference to server
                    saveSoundPreference(isMusicEnabled);
                });
            }
            
            // Setup game event listeners
            playAgainBtn.addEventListener('click', resetGame);
            homeBtn.addEventListener('click', goToHome);
            
            // Setup profile button
            const profileButton = document.getElementById('profile-button');
            if (profileButton) {
                profileButton.addEventListener('click', function() {
                    // Show settings screen
                    document.getElementById('settings-screen').style.display = 'block';
                });
            }
            
            // Setup settings close button
            const closeSettingsBtn = document.getElementById('close-settings');
            if (closeSettingsBtn) {
                closeSettingsBtn.addEventListener('click', function() {
                    // Hide settings screen
                    document.getElementById('settings-screen').style.display = 'none';
                });
            }
            
            // Setup username input
            const usernameInput = document.getElementById('username-input');
            if (usernameInput) {
                usernameInput.addEventListener('change', function() {
                    // Update username
                    username = this.value;
                    document.getElementById('username').textContent = username;
                    
                    // Save to server
                    sendUserDataToServer();
                });
            }
            
            // Setup PayPal email input
            const paypalEmailInput = document.getElementById('paypal-email');
            if (paypalEmailInput) {
                paypalEmailInput.addEventListener('change', function() {
                    // Update PayPal email
                    paypalEmail = this.value;
                    
                    // Save to server
                    sendUserDataToServer();
                });
            }
            
            // Set initial game mode
            gameMode = 'home';
            
            // Initialize background music
            manageBackgroundMusic();
            
            // Start game loop
            gameRunning = true;
            requestAnimationFrame(gameLoop);
        });
        
        // Function to manage background music
        function manageBackgroundMusic() {
            if (gameMode === 'home') {
                // On home screen, play music if enabled
                if (isMusicEnabled) {
                    playBackgroundMusic();
                }
            } else if (gameMode === 'game') {
                // During gameplay, stop music
                stopBackgroundMusic();
            }
        }
        
        // Function to play background music
        function playBackgroundMusic() {
            try {
                if (!isMusicEnabled) return;
                
                const backgroundMusicElement = document.getElementById('backgroundMusic');
                if (!backgroundMusicElement) return;
                
                // If no music is currently selected or playing, pick a random one
                if (currentMusicIndex === -1 || backgroundMusicElement.paused) {
                    // Pick a random music from the list
                    const newIndex = Math.floor(Math.random() * homeMusics.length);
                    currentMusicIndex = newIndex;
                    
                    // Set the source
                    backgroundMusicElement.src = homeMusics[currentMusicIndex];
                    
                    // Set volume
                    backgroundMusicElement.volume = 0.3;
                    
                    // Play the music
                    const playPromise = backgroundMusicElement.play();
                    
                    // Handle autoplay restrictions
                    if (playPromise !== undefined) {
                        playPromise.catch(error => {
                            console.log('Autoplay prevented:', error);
                            window.musicPendingAutoplay = true;
                        });
                    }
                }
            } catch (error) {
                console.error('Error playing background music:', error);
            }
        }
        
        // Function to stop background music
        function stopBackgroundMusic() {
            try {
                const backgroundMusicElement = document.getElementById('backgroundMusic');
                if (backgroundMusicElement && !backgroundMusicElement.paused) {
                    backgroundMusicElement.pause();
                }
            } catch (error) {
                console.error('Error stopping background music:', error);
            }
        }
        
        // Function to save sound preference to server
        function saveSoundPreference(enabled) {
            try {
                // Send preference to server
                fetch('/api/users/preferences', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        userId: userId,
                        musicEnabled: enabled
                    })
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to save sound preference');
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Sound preference saved:', data);
                })
                .catch(error => {
                    console.error('Error saving sound preference:', error);
                });
            } catch (error) {
                console.error('Error in saveSoundPreference:', error);
            }
        }
        
        // Function to load sound preference from server
        function loadSoundPreference() {
            try {
                if (!userId) return;
                
                // Get preference from server
                fetch(`/api/users/${userId}/preferences`)
                    .then(response => {
                        if (!response.ok) {
                            if (response.status === 404) {
                                return { musicEnabled: false };
                            }
                            throw new Error('Failed to load sound preference');
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data && data.musicEnabled !== undefined) {
                            isMusicEnabled = data.musicEnabled;
                            userPrefersMusicEnabled = data.musicEnabled;
                            
                            // Update UI
                            const soundToggleBtn = document.getElementById('sound-toggle');
                            if (soundToggleBtn) {
                                soundToggleBtn.classList.toggle('muted', !isMusicEnabled);
                            }
                            
                            // Update music playback
                            if (isMusicEnabled && gameMode === 'home') {
                                playBackgroundMusic();
                            }
                        }
                    })
                    .catch(error => {
                        console.error('Error loading sound preference:', error);
                    });
            } catch (error) {
                console.error('Error in loadSoundPreference:', error);
            }
        }
    </script>
</body>
</html>
