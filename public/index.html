<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- Méta-tags pour forcer l'orientation portrait -->
    <meta name="screen-orientation" content="portrait">
    <meta name="x5-orientation" content="portrait">
    <meta name="msapplication-orientation" content="portrait">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>TiDash Game</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <!-- Préchargement des sons -->
    <audio id="userTapSound" src="sounds/UserTap.mp3" preload="auto"></audio>
    <audio id="successSound" src="sounds/Success.mp3" preload="auto"></audio>
    <audio id="gameOverSound" src="sounds/Termine.mp3" preload="auto"></audio>
    <audio id="showScoreSound" src="sounds/Show_GameOver.mp3" preload="auto"></audio>
    <audio id="borderTouchSound" src="sounds/BorderTouch.mp3" preload="auto"></audio>
    <!-- Élément audio pour la musique de fond -->
    <audio id="backgroundMusic" preload="auto" loop></audio>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        
        body {
            font-family: 'Orbitron', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #0A0A0A; /* Noir presque pur */
            overflow: hidden;
            touch-action: manipulation;
            position: relative;
        }
        
        .container {
            position: relative;
            width: 90%;
            max-width: 400px;
            height: 90vh; /* Augmenté de 80vh à 90vh pour réduire l'espace vertical */
            max-height: 800px; /* Augmenté pour maintenir les proportions */
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            background-color: #121212; /* Gris très foncé */
            border: 10px solid #0A0A0A;
            margin: 20px auto; /* Ajout d'une marge automatique pour centrer avec moins d'espace vertical */
        }
        
        #game-canvas {
            background-color: #121212; /* Gris très foncé - même que le container */
            background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)); /* Même superposition que le home-screen */
            display: block;
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 1;
        }
        
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #121212; /* Gris très foncé - même que le container */
            background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)); /* Même superposition que le home-screen */
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
            font-family: 'Orbitron', sans-serif;
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }
        
        #game-over.visible {
            opacity: 1;
        }
        
        #score-display {
            font-size: 4rem;
            margin-bottom: 10px;
            color: #00FF9D; /* Vert original */
            font-weight: bold;
            transform: translateY(20px);
            opacity: 0;
            transition: all 0.5s ease-out;
            transition-delay: 0.3s;
        }
        
        #best-score {
            font-size: 1.8rem;
            margin-bottom: 30px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 1px;
            transform: translateY(20px);
            opacity: 0;
            transition: all 0.5s ease-out;
            transition-delay: 0.6s;
        }
        
        .button-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            transform: translateY(20px);
            opacity: 0;
            transition: all 0.5s ease-out;
            transition-delay: 0.9s;
        }
        
        #game-over.visible #score-display,
        #game-over.visible #best-score,
        #game-over.visible .button-container {
            transform: translateY(0);
            opacity: 1;
        }
        
        #home-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 0;
            box-sizing: border-box;
            pointer-events: auto;
            z-index: 5;
            background-color: rgba(0, 0, 0, 0.3); /* Légèrement transparent */
        }
        
        #game-title-container {
            text-align: center;
            margin-bottom: 50px;
            z-index: 6;
        }
        
        #game-button-container {
            text-align: center;
            margin-top: 50px;
            z-index: 6;
        }
        
        .button-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #game-title {
            font-size: 4.5rem;
            font-weight: bold;
            color: #FFFFFF;
            letter-spacing: 2px;
            text-shadow: 
                0 2px 0 rgba(0, 0, 0, 0.5),
                0 4px 0 rgba(0, 255, 157, 0.3),
                0 6px 10px rgba(0, 0, 0, 0.3);
            transform: perspective(500px) rotateX(10deg);
            margin-bottom: 10px;
        }
        
        #score-display {
            font-size: 4rem;
            margin-bottom: 10px;
            color: #00FF9D; /* Vert original */
            font-weight: bold;
        }
        
        #best-score {
            font-size: 1.8rem;
            margin-bottom: 30px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .game-button {
            padding: 12px 24px;
            font-size: 1.2rem;
            background: linear-gradient(135deg, #00FF9D 0%, #00B38B 70%, #009E7F 100%);
            color: #121212;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            margin: 10px 0;
            min-width: 150px;
            text-align: center;
            font-weight: bold;
            letter-spacing: 1px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            text-transform: uppercase;
        }
        
        .game-button:hover {
            background: linear-gradient(135deg, #00FFB3 0%, #00C49C 70%, #00AF8F 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
        }
        
        .game-button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .game-button.secondary {
            background: transparent;
            color: white;
            border: 2px solid white;
            box-shadow: none;
        }
        
        .game-button.secondary:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        
        /* Style pour le profil utilisateur */
        .user-profile {
            position: absolute;
            top: 20px;
            right: 20px;
            left: auto;
            display: flex;
            align-items: center;
            z-index: 10;
            flex-direction: row-reverse; /* Inverser l'ordre pour mettre l'avatar à droite */
        }
        
        .avatar-container {
            width: 32px;
            height: 32px;
            border-radius: 7px;
            position: relative;
            margin-left: 6px;
            margin-right: 0;
        }
        
        .avatar-border {
            position: absolute;
            top: -1.5px;
            left: -1.5px;
            right: -1.5px;
            bottom: -1.5px;
            border-radius: 8.5px;
            background: linear-gradient(45deg, #00FF9D, #00A86B);
            z-index: -1;
        }
        
        .avatar-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 5.5px;
        }
        
        .user-info {
            color: white;
            text-align: right; /* Aligner le texte à droite */
        }
        
        .username {
            font-size: 11px;
            font-weight: bold;
            margin: 0;
            margin-bottom: 2px; /* Espacement entre username et ID */
        }
        
        .user-id {
            font-size: 9px;
            color: #aaa;
            margin: 0;
        }
        
        /* Styles pour la page de paramètres */
        #settings-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: none;
            z-index: 10;
        }
        
        .settings-content {
            width: 100%;
            height: 100%;
            overflow-y: scroll;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
            touch-action: pan-y;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }
        
        .settings-title {
            font-size: 24px;
            font-weight: bold;
            color: white;
        }
        
        .close-button {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        
        .close-button:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        
        .close-icon {
            color: white;
            font-size: 20px;
        }
        
        .profile-card {
            background-color: rgba(30, 30, 30, 0.8);
            border-radius: 12px;
            padding: 15px;
            display: flex;
            align-items: center;
            margin-bottom: 30px;
        }
        
        .profile-avatar {
            width: 70px;
            height: 70px;
            border-radius: 12px;
            margin-right: 15px;
            position: relative;
            overflow: hidden;
        }
        
        .profile-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .profile-avatar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 2px solid #00FF9D;
            border-radius: 12px;
            box-sizing: border-box;
        }
        
        .profile-info {
            flex: 1;
        }
        
        .username-container {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .username-input {
            background-color: transparent;
            border: none;
            color: white;
            font-size: 18px;
            font-weight: bold;
            font-family: 'Orbitron', sans-serif;
            padding: 5px 0;
            width: calc(100% - 30px);
            outline: none;
        }
        
        .edit-icon {
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-left: 10px;
        }
        
        .user-id-display {
            font-size: 14px;
            color: #aaa;
        }
        
        .paypal-section {
            margin-bottom: 30px;
        }
        
        .section-title {
            font-size: 16px;
            color: white;
            margin-bottom: 15px;
        }
        
        .paypal-input {
            width: 100%;
            background-color: rgba(30, 30, 30, 0.8);
            border: none;
            border-radius: 8px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            padding: 12px 15px;
            box-sizing: border-box;
            margin-bottom: 15px;
            outline: none;
        }
        
        .input-container {
            position: relative;
            margin-bottom: 15px;
        }
        
        .input-edit-icon {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: white;
        }
        
        .description-text {
            font-size: 12px;
            color: #aaa;
            line-height: 1.5;
        }
        
        .avatars-section {
            margin-bottom: 30px;
        }
        
        .avatars-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }
        
        .avatar-item {
            width: 100%;
            aspect-ratio: 1/1;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            cursor: pointer;
        }
        
        .avatar-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .avatar-item.selected::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 2px solid #00FF9D;
            border-radius: 12px;
            box-sizing: border-box;
        }
        
        .avatar-check {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 20px;
            height: 20px;
            background-color: #00FF9D;
            border-radius: 50%;
            display: none;
            justify-content: center;
            align-items: center;
            color: black;
            font-weight: bold;
            font-size: 12px;
        }
        
        .avatar-item.selected .avatar-check {
            display: flex;
        }
        
        /* Styles pour le bouton de son */
        .sound-toggle {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 100;
            transition: all 0.2s ease;
        }
        
        .sound-toggle:hover {
            background-color: rgba(0, 0, 0, 0.7);
            transform: scale(1.1);
        }
        
        .sound-toggle svg {
            width: 24px;
            height: 24px;
        }
        
        .sound-toggle.muted .sound-on {
            display: none;
        }
        
        .sound-toggle:not(.muted) .sound-off {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Profil utilisateur -->
        <div class="user-profile" id="profile-button">
            <div class="avatar-container">
                <div class="avatar-border"></div>
                <img id="avatarImg" class="avatar-img" src="avatars/avatar_default.jpg" alt="Avatar">
            </div>
            <div class="user-info">
                <p id="username" class="username">Username</p>
                <p id="userId" class="user-id">0000000000</p>
            </div>
        </div>
        
        <canvas id="game-canvas"></canvas>
        
        <div id="home-screen">
            <div id="game-title-container">
                <div id="game-title">TiDash</div>
            </div>
            <div id="game-button-container">
                <button id="play-button" class="game-button">Tap to Start</button>
            </div>
            
            <!-- Bouton pour activer/désactiver le son -->
            <div id="sound-toggle" class="sound-toggle muted">
                <svg class="sound-on" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M14.5 8.5C14.5 8.5 16 9.57 16 12C16 14.43 14.5 15.5 14.5 15.5" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M18 5C18 5 21 7 21 12C21 17 18 19 18 19" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M3 10.5V13.5C3 14.6046 3.5 15.5 5 15.5C6.5 15.5 7 14.6046 7 13.5V10.5C7 9.39543 6.5 8.5 5 8.5C3.5 8.5 3 9.39543 3 10.5Z" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M7 10L11 7V17L7 14" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <svg class="sound-off" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M2 9L22 21" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M11 7L7 10H5C3.5 10 3 10.8954 3 12V12C3 13.1046 3.5 14 5 14H7L11 17V7Z" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M14.5 10.5C14.5 10.5 15.0049 10.7705 15.5 11.5" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M18 8C18 8 19.5 9.5 19.5 12" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </div>
        </div>
        <div id="game-over">
            <div id="score-display">0</div>
            <div id="best-score">Best: 0</div>
            <div class="button-container">
                <button id="play-again" class="game-button">PLAY AGAIN</button>
                <button id="home-button" class="game-button secondary">HOME</button>
            </div>
        </div>
        
        <!-- Page de paramètres -->
        <div id="settings-screen">
            <div class="settings-content">
                <div class="settings-header">
                    <div class="settings-title">Settings</div>
                    <div class="close-button" id="close-settings">
                        <span class="close-icon">✕</span>
                    </div>
                </div>
                
                <div class="profile-card">
                    <div class="profile-avatar">
                        <img id="settings-avatar" src="avatars/avatar_default.jpg" alt="Avatar">
                    </div>
                    <div class="profile-info">
                        <div class="username-container">
                            <input type="text" id="username-input" class="username-input" value="Username">
                            <div class="edit-icon">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M16.4745 5.40768L18.5917 7.52483M17.8358 3.54254L11.6002 9.77806C11.3979 9.98031 11.2619 10.2384 11.2104 10.5192L10.5798 13.4209L13.4816 12.7903C13.7624 12.7388 14.0205 12.6028 14.2227 12.4006L20.4582 6.16508C20.5844 6.03889 20.6846 5.88909 20.7536 5.72343C20.8226 5.55777 20.8589 5.37966 20.8605 5.19938C20.8621 5.01909 20.8289 4.84039 20.7628 4.6736C20.6967 4.50681 20.5991 4.35537 20.4749 4.22718C20.3507 4.09899 20.2022 3.99691 20.0374 3.92553C19.8726 3.85415 19.6951 3.81549 19.5157 3.81169C19.3364 3.8079 19.1574 3.83906 18.9899 3.90281C18.8224 3.96656 18.6698 4.06188 18.5401 4.18348L12.3046 10.419C12.1023 10.6212 11.9664 10.8793 11.9149 11.1601L11.2843 14.0619L14.186 13.4313C14.4668 13.3798 14.7249 13.2438 14.9272 13.0416L21.1627 6.80608C21.8106 6.15818 22.1655 5.28206 22.1529 4.36728C22.1403 3.45249 21.7612 2.58647 21.0961 1.9549C20.431 1.32333 19.5401 0.96993 18.6146 1.00182C17.689 1.03372 16.8179 1.44959 16.1974 2.12483L9.96196 8.36035C9.35302 8.96929 8.94371 9.74882 8.79747 10.5981L7.7655 15.2322C7.73328 15.3697 7.73471 15.5131 7.76969 15.6498C7.80467 15.7864 7.87221 15.9122 7.96643 16.0172C8.06066 16.1222 8.17871 16.2034 8.31082 16.2544C8.44293 16.3054 8.58559 16.3247 8.72856 16.3108L13.3627 15.2788C14.212 15.1326 14.9915 14.7233 15.6004 14.1143L21.8359 7.87877L16.4745 5.40768Z" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </div>
                    </div>
                    <div class="user-id-display">ID : <span id="settings-user-id">0000000000</span></div>
                </div>
            </div>
                
                <div class="paypal-section">
                    <div class="section-title">Enter your PayPal email address</div>
                    <div class="input-container">
                        <input type="email" id="paypal-email" class="paypal-input" placeholder="mypaypal@email.com">
                        <div class="input-edit-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M16.4745 5.40768L18.5917 7.52483M17.8358 3.54254L11.6002 9.77806C11.3979 9.98031 11.2619 10.2384 11.2104 10.5192L10.5798 13.4209L13.4816 12.7903C13.7624 12.7388 14.0205 12.6028 14.2227 12.4006L20.4582 6.16508C20.5844 6.03889 20.6846 5.88909 20.7536 5.72343C20.8226 5.55777 20.8589 5.37966 20.8605 5.19938C20.8621 5.01909 20.8289 4.84039 20.7628 4.6736C20.6967 4.50681 20.5991 4.35537 20.4749 4.22718C20.3507 4.09899 20.2022 3.99691 20.0374 3.92553C19.8726 3.85415 19.6951 3.81549 19.5157 3.81169C19.3364 3.8079 19.1574 3.83906 18.9899 3.90281C18.8224 3.96656 18.6698 4.06188 18.5401 4.18348L12.3046 10.419C12.1023 10.6212 11.9664 10.8793 11.9149 11.1601L11.2843 14.0619L14.186 13.4313C14.4668 13.3798 14.7249 13.2438 14.9272 13.0416L21.1627 6.80608C21.8106 6.15818 22.1655 5.28206 22.1529 4.36728C22.1403 3.45249 21.7612 2.58647 21.0961 1.9549C20.431 1.32333 19.5401 0.96993 18.6146 1.00182C17.689 1.03372 16.8179 1.44959 16.1974 2.12483L9.96196 8.36035C9.35302 8.96929 8.94371 9.74882 8.79747 10.5981L7.7655 15.2322C7.73328 15.3697 7.73471 15.5131 7.76969 15.6498C7.80467 15.7864 7.87221 15.9122 7.96643 16.0172C8.06066 16.1222 8.17871 16.2034 8.31082 16.2544C8.44293 16.3054 8.58559 16.3247 8.72856 16.3108L13.3627 15.2788C14.212 15.1326 14.9915 14.7233 15.6004 14.1143L21.8359 7.87877L16.4745 5.40768Z" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </div>
                    </div>
                    <div class="description-text">
                        This is where your prize money will be sent if you win 1st place in the season ranking. Make sure your PayPal account is active and the email entered is correct, as this is how we will transfer your winnings!
                    </div>
                </div>
                
                <div class="avatars-section">
                    <div class="section-title">Select your avatar</div>
                    <div class="avatars-grid" id="avatars-grid">
                        <!-- Les avatars seront ajoutés dynamiquement ici -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const tg = window.Telegram.WebApp;
        const gameOverScreen = document.getElementById('game-over');
        const homeScreen = document.getElementById('home-screen');
        const scoreDisplay = document.getElementById('score-display');
        const bestScoreDisplay = document.getElementById('best-score');
        const playAgainBtn = document.getElementById('play-again');
        const homeBtn = document.getElementById('home-button');
        const playBtn = document.getElementById('play-button');

        // Désactiver le zoom sur mobile
        document.addEventListener('touchmove', function (event) {
            if (event.scale !== 1) {
                event.preventDefault();
            }
        }, { passive: false });
        
        // Double-tap prevention
        document.addEventListener('touchend', function(event) {
            const now = Date.now();
            const DOUBLE_TAP_THRESHOLD = 300;
            if (now - lastTouchEnd <= DOUBLE_TAP_THRESHOLD) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
        
        let lastTouchEnd = 0;

        // Game variables
        let gameRunning = false;
        let gameMode = 'home'; // 'home', 'game', 'gameOver'
        let score = 0;
        let bestScore = localStorage.getItem('bestScore') || 0;
        
        // Variables pour les étoiles
        let stars = [];
        const maxStars = 40; // Nombre d'étoiles
        
        // Variables pour le profil utilisateur
        let username = "";
        let userId = "";
        let avatarSrc = "avatars/avatar_default.jpg";
        let paypalEmail = "";
        
        // Variables pour la musique de fond
        let homeMusics = [
            "home_musics/dont-talk-315229.mp3",
            "home_musics/Onchain.mp3",
            "home_musics/gardens-stylish-chill-303261.mp3",
            "home_musics/gorila-315977 (1).mp3",
            "home_musics/ClicClic.mp3",
            "home_musics/night-detective-226857.mp3"
        ];
        let currentMusicIndex = -1;
        let backgroundMusicElement = document.getElementById('backgroundMusic');
        
        // Variable pour suivre si la musique est en attente d'autoplay
        window.musicPendingAutoplay = true;
        
        // Variables pour gérer séparément la musique de fond et les effets sonores
        let isMusicEnabled = false; // Contrôle uniquement la musique de fond
        let isGameSoundEnabled = true; // Contrôle uniquement les effets sonores du jeu (toujours activés par défaut)
        let userPrefersMusicEnabled = localStorage.getItem('tidashMusicEnabled') === 'true';
        
        // Variable pour suivre si la musique a déjà été activée par l'utilisateur
        let musicActivatedByUser = false;
        
        // Système audio optimisé pour mobile avec Web Audio API
        let audioContext;
        const audioBuffers = {};
        const audioSources = {};
        let audioInitialized = false;
        
        // Initialiser le système audio
        function initAudioSystem() {
            try {
                // Créer le contexte audio
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                audioContext = new AudioContext();
                
                // Précharger les sons
                preloadSounds();
                
                // Marquer comme initialisé
                audioInitialized = true;
                
                console.log("Système audio initialisé");
            } catch (error) {
                console.error("Erreur d'initialisation audio:", error);
                // Fallback à la méthode standard si Web Audio API n'est pas supportée
                audioInitialized = false;
            }
        }
        
        // Précharger les sons pour une lecture instantanée
        function preloadSounds() {
            const sounds = {
                'userTap': document.getElementById('userTapSound'),
                'success': document.getElementById('successSound'),
                'gameOver': document.getElementById('gameOverSound'),
                'showScore': document.getElementById('showScoreSound'),
                'borderTouch': document.getElementById('borderTouchSound')
            };
            
            // Pour chaque son
            for (const [name, audioElement] of Object.entries(sounds)) {
                if (!audioElement) continue;
                
                // Stocker l'élément audio pour le fallback
                audioSources[name] = audioElement;
                
                // Précharger avec Web Audio API
                if (audioContext) {
                    fetch(audioElement.src)
                        .then(response => response.arrayBuffer())
                        .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
                        .then(audioBuffer => {
                            audioBuffers[name] = audioBuffer;
                            console.log(`Son ${name} préchargé`);
                        })
                        .catch(error => {
                            console.error(`Erreur lors du préchargement du son ${name}:`, error);
                        });
                }
            }
        }
        
        // Jouer un son avec le moins de latence possible
        function playSound(name) {
            // Ne jouer les sons que si on est en mode jeu et si le son est activé
            if (gameMode !== 'game' && name === 'borderTouch') {
                return;
            }
            
            if (!isGameSoundEnabled) {
                return;
            }
            
            // Si le système audio n'est pas initialisé, l'initialiser
            if (!audioInitialized && typeof AudioContext !== 'undefined') {
                initAudioSystem();
            }
            
            try {
                // Si Web Audio API est disponible et le son est préchargé
                if (audioInitialized && audioContext && audioBuffers[name]) {
                    // Vérifier si le contexte est suspendu (restriction mobile)
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                    
                    // Créer une source sonore
                    const source = audioContext.createBufferSource();
                    source.buffer = audioBuffers[name];
                    
                    // Connecter à la sortie audio
                    source.connect(audioContext.destination);
                    
                    // Jouer immédiatement
                    source.start(0);
                    return;
                }
                
                // Fallback à la méthode standard
                if (audioSources[name]) {
                    const audio = audioSources[name];
                    audio.currentTime = 0;
                    
                    // Utiliser une promesse pour gérer la lecture
                    const playPromise = audio.play();
                    if (playPromise !== undefined) {
                        playPromise.catch(error => {
                            console.error(`Erreur de lecture audio (${name}):`, error);
                            
                            // Si l'erreur est liée à l'interaction utilisateur, initialiser le système audio
                            if (error.name === 'NotAllowedError') {
                                // On ne peut rien faire ici, il faut une interaction utilisateur
                                console.log("Interaction utilisateur requise pour la lecture audio");
                            }
                        });
                    }
                }
            } catch (error) {
                console.error(`Erreur lors de la lecture du son ${name}:`, error);
            }
        }
        
        // Activer l'audio sur interaction utilisateur
        function setupAudioActivation() {
            const activateAudio = () => {
                // Initialiser le système audio
                if (!audioInitialized) {
                    initAudioSystem();
                }
                
                // Jouer un son silencieux pour débloquer l'audio sur mobile
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log("Contexte audio repris");
                        
                        // Créer un oscillateur silencieux pour "réveiller" l'audio
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        gainNode.gain.value = 0; // Volume à 0
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        oscillator.start(0);
                        oscillator.stop(audioContext.currentTime + 0.001); // Jouer pendant 1ms
                    });
                }
                
                // Supprimer les écouteurs d'événements
                document.removeEventListener('click', activateAudio, true);
                document.removeEventListener('touchstart', activateAudio, true);
                document.removeEventListener('keydown', activateAudio, true);
            };
            
            // Ajouter les écouteurs d'événements
            document.addEventListener('click', activateAudio, true);
            document.addEventListener('touchstart', activateAudio, true);
            document.addEventListener('keydown', activateAudio, true);
        }
        
        let ball = {
            x: 0,
            y: 0,
            radius: 0,
            speed: 0,
            direction: 1 // 1 for right, -1 for left
        };
        let line = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        };
        let squares = [];
        let fadingSquares = []; // Squares that are fading out
        let particles = []; // Particles for ball explosion
        let gameOverAnimation = false;
        let gameOverAnimationComplete = false;
        let lastSquareTime = 0;
        let squareInterval = 1100; // Intervalle augmenté pour réduire la difficulté
        let lastFrameTime = 0;
        let greenSquareChance = 0.2; // 20% chance for green squares
        let lineProximityThreshold = 0; // Distance minimale entre les carrés et la ligne
        let canSpawnNewSquare = true; // Variable pour contrôler l'apparition des carrés

        // Return to home screen
        function goToHome() {
            gameMode = 'home';
            gameOverScreen.style.display = 'none';
            homeScreen.style.display = 'flex';
            gameOverAnimation = false;
            gameOverAnimationComplete = false;
            
            // Réafficher le profil utilisateur sur l'écran d'accueil
            document.getElementById("profile-button").style.display = 'flex';
            
            // Make sure the game loop is running for the home screen animation
            if (!gameRunning) {
                gameRunning = true;
                requestAnimationFrame(gameLoop);
            }
            
            // Gérer la musique de fond (démarrer sur l'écran d'accueil)
            manageBackgroundMusic();
        }

        // Initialize the game
        function initGame() {
            // Set canvas size to match container
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            // Initialize ball - larger radius
            ball.radius = canvas.width * 0.035;
            ball.y = canvas.height * 0.5; // Middle of the screen vertically
            ball.x = canvas.width / 2;
            ball.speed = canvas.width * 0.0008; // Slightly faster speed
            ball.direction = 1;
            
            // Initialize line - 80% of width and same height as ball
            line.width = canvas.width * 0.8;
            line.height = ball.radius * 2; // Same height as the ball diameter
            line.x = (canvas.width - line.width) / 2;
            line.y = ball.y - ball.radius; // Center the ball on the line
            
            // Initialiser les étoiles
            initStars();
            
            // Configurer l'activation audio
            setupAudioActivation();
            
            // Initialiser le profil utilisateur
            initUserProfile();
            
            // Envoyer les données utilisateur au serveur pour le panneau d'admin
            sendUserDataToServer();
            
            // Reset game state
            squares = [];
            fadingSquares = [];
            particles = [];
            gameOverAnimation = false;
            gameOverAnimationComplete = false;
            score = 0;
            
            // Start game loop if not already running
            if (!gameRunning) {
                gameRunning = true;
                requestAnimationFrame(gameLoop);
            }
        }
        
        // Initialiser les étoiles
        function initStars() {
            stars = [];
            for (let i = 0; i < maxStars; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 1.2 + 0.3, // Taille entre 0.3 et 1.5 pixels
                    opacity: Math.random() * 0.4 + 0.3, // Opacité entre 0.3 et 0.7 (augmentée pour plus de visibilité)
                    speed: Math.random() * 0.2 + 0.05, // Vitesse entre 0.05 et 0.25 pixels par frame
                    direction: Math.random() * Math.PI * 2 // Direction aléatoire en radians
                });
            }
        }
        
        // Dessiner les étoiles
        function drawStars() {
            // Ne dessiner les étoiles que sur l'écran d'accueil et pendant le jeu
            if (gameMode === 'home' || gameMode === 'game') {
                for (let i = 0; i < stars.length; i++) {
                    const star = stars[i];
                    
                    // Mise à jour de la position
                    star.x += Math.cos(star.direction) * star.speed;
                    star.y += Math.sin(star.direction) * star.speed;
                    
                    // Si l'étoile sort de l'écran, la replacer de l'autre côté
                    if (star.x < 0) star.x = canvas.width;
                    if (star.x > canvas.width) star.x = 0;
                    if (star.y < 0) star.y = canvas.height;
                    if (star.y > canvas.height) star.y = 0;
                    
                    // Dessiner l'étoile
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
                    ctx.fill();
                }
            }
        }

        // Start the actual gameplay
        function startGame() {
            // Hide home screen
            homeScreen.style.display = 'none';
            
            // Masquer le profil utilisateur pendant le jeu
            document.getElementById("profile-button").style.display = 'none';
            
            // Reset game state
            resetGame();
            
            // Réinitialiser les variables de jeu
            gameOverAnimation = false;
            gameOverAnimationComplete = false;
            
            // Set game mode to 'game'
            gameMode = 'game';
            
            // Gérer la musique de fond (arrêter pendant le jeu)
            manageBackgroundMusic();
            
            // Force restart game loop
            gameRunning = true;
            lastFrameTime = null;
            
            // Réinitialiser la position et la vitesse de la balle
            ball.x = canvas.width / 2;
            ball.y = canvas.height * 0.5;
            ball.direction = Math.random() > 0.5 ? 1 : -1;
            ball.speed = canvas.width * 0.0008;
            
            // Réinitialiser la position de la ligne
            line.x = (canvas.width - line.width) / 2;
            line.y = ball.y - ball.radius;
            
            // Démarrer la boucle de jeu
            requestAnimationFrame(gameLoop);
        }

        // Game loop
        function gameLoop(timestamp) {
            if (!lastFrameTime) lastFrameTime = timestamp;
            const deltaTime = timestamp - lastFrameTime;
            lastFrameTime = timestamp;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Dessiner les étoiles en arrière-plan
            drawStars();
            
            // Mettre à jour la position de la balle pour tous les modes
            if (gameMode !== 'gameOver' || !gameOverAnimation) {
                ball.x += ball.speed * ball.direction * deltaTime;
                
                // Check if ball hits the edge of the line
                if (ball.x - ball.radius < line.x) {
                    ball.x = line.x + ball.radius;
                    ball.direction = 1;
                    // Jouer le son quand la balle touche le bord gauche
                    playSound('borderTouch');
                } else if (ball.x + ball.radius > line.x + line.width) {
                    ball.x = line.x + line.width - ball.radius;
                    ball.direction = -1;
                    // Jouer le son quand la balle touche le bord droit
                    playSound('borderTouch');
                }
            }
            
            // Always draw the line
            drawLine();
            
            // Ne dessiner la balle que si on n'est pas en animation de game over
            if (gameMode !== 'gameOver' || !gameOverAnimation) {
                drawBall();
            }
            
            if (gameMode === 'game' || gameMode === 'gameOver') {
                // Update and draw particles - Déplacer avant les carrés pour que les particules soient visibles
                updateParticles(deltaTime);
                
                // Update and draw squares
                updateSquares(deltaTime);
                
                // Update and draw fading squares
                updateFadingSquares(deltaTime);
                
                if (gameMode === 'game') {
                    // Check for collisions
                    if (checkCollisions()) {
                        return;
                    }
                    
                    // Spawn new squares
                    if ((squares.length === 0) || (squares.length > 0 && squares[squares.length-1].y > canvas.height * 0.20)) {
                        spawnSquare();
                        lastSquareTime = Date.now();
                        
                        // Gradually decrease spawn interval
                        if (squareInterval > 500) {
                            squareInterval -= 10;
                        }
                    }
                    
                    // Draw score
                    drawScore();
                }
            }
            
            // Continue the game loop
            if (gameRunning) {
                requestAnimationFrame(gameLoop);
            }
        }

        // Spawn a new square
        function spawnSquare() {
            // Larger squares
            const size = canvas.width * 0.07;
            
            // Make sure squares pass through the horizontal line
            // Calculate a position that will ensure the square passes through the line
            const lineCenter = line.x + line.width / 2;
            const lineWidth = line.width;
            
            // Random position that ensures passing through the line
            const minX = Math.max(0, line.x - size);
            const maxX = Math.min(canvas.width - size, line.x + line.width);
            const x = minX + Math.random() * (maxX - minX);
            
            const isGreen = Math.random() < greenSquareChance;
            
            // Random diagonal angle for falling, but ensure it passes through the line
            const targetX = line.x + Math.random() * line.width;
            const targetY = line.y;
            
            // Calculate angle to ensure it passes through the line
            const dx = targetX - (x + size/2);
            const dy = targetY - (-size/2);
            const angle = Math.atan2(dx, dy);
            
            // Limit the angle to prevent too horizontal trajectories
            const limitedAngle = Math.max(Math.min(angle, Math.PI/4), -Math.PI/4);
            
            squares.push({
                x: x,
                y: -size,
                size: size,
                speed: canvas.height * 0.0005, // Revenir à la vitesse originale
                isGreen: isGreen,
                rotation: 0,
                rotationSpeed: 0.01 * (Math.random() > 0.5 ? 1 : -1), // Vitesse de rotation fixe et modérée
                angle: limitedAngle,
                velocityX: Math.sin(limitedAngle),
                velocityY: Math.cos(limitedAngle)
            });
        }

        // Update squares positions
        function updateSquares(deltaTime) {
            // Update regular squares
            for (let i = squares.length - 1; i >= 0; i--) {
                const square = squares[i];
                
                if (!gameOverAnimation) {
                    // Move square diagonally
                    square.x += square.velocityX * square.speed * deltaTime;
                    square.y += square.velocityY * square.speed * deltaTime;
                }
                
                // Update rotation
                square.rotation += square.rotationSpeed * deltaTime;
                
                // Check if square has reached the bottom area (above score)
                const scoreAreaY = canvas.height * 0.7; // Position plus haute (70% au lieu de 80%)
                
                if (square.y > scoreAreaY && !gameOverAnimation) {
                    // Add to fading squares and remove from regular squares
                    square.fadeStartTime = Date.now();
                    square.fadeTime = 1500; // 1.5 seconds for fade animation
                    square.originalSize = square.size;
                    fadingSquares.push(square);
                    squares.splice(i, 1);
                    continue;
                }
                
                // Remove squares that are off-screen horizontally
                if ((square.x < -square.size || square.x > canvas.width) && !gameOverAnimation) {
                    squares.splice(i, 1);
                    continue;
                }
                
                // Draw rotating square
                ctx.save();
                ctx.translate(square.x + square.size/2, square.y + square.size/2);
                ctx.rotate(square.rotation);
                ctx.fillStyle = square.isGreen ? '#00FF9D' : '#FFFFFF'; // Couleur verte pour les carrés verts
                ctx.fillRect(-square.size/2, -square.size/2, square.size, square.size);
                ctx.restore();
            }
        }

        // Update fading squares
        function updateFadingSquares(deltaTime) {
            for (let i = fadingSquares.length - 1; i >= 0; i--) {
                const square = fadingSquares[i];
                
                // Calculate how much time has passed since fade started
                const fadeElapsed = Date.now() - square.fadeStartTime;
                const fadeProgress = Math.min(fadeElapsed / square.fadeTime, 1);
                
                // Update rotation (continue rotating while fading)
                square.rotation += square.rotationSpeed * deltaTime;
                
                // Calculate new size based on fade progress (shrink to nothing)
                const newSize = square.originalSize * (1 - fadeProgress);
                
                // Remove if fade is complete
                if (fadeProgress >= 1) {
                    fadingSquares.splice(i, 1);
                    continue;
                }
                
                // Draw fading square
                ctx.save();
                ctx.translate(square.x + square.originalSize/2, square.y + square.originalSize/2);
                ctx.rotate(square.rotation);
                ctx.fillStyle = square.isGreen ? '#00FF9D' : '#FFFFFF'; // Couleur verte pour les carrés verts
                ctx.globalAlpha = 1 - fadeProgress; // Also fade opacity
                ctx.fillRect(-newSize/2, -newSize/2, newSize, newSize);
                ctx.globalAlpha = 1;
                ctx.restore();
            }
        }

        // Create explosion particles from the ball
        function createExplosion(x, y, color) {
            const particleCount = 120; // Augmenter légèrement le nombre de particules
            const particleSize = ball.radius / 4; // Particules plus fines (divisé par 4 au lieu de 2)
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 8 + 3; // Vitesse plus élevée
                const distance = Math.random() * ball.radius;
                
                particles.push({
                    x: x + Math.cos(angle) * distance,
                    y: y + Math.sin(angle) * distance,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: particleSize * (Math.random() * 0.5 + 0.3), // Particules plus fines
                    color: color || '#00FF9D',
                    alpha: 1,
                    fadeSpeed: 0.01 + Math.random() * 0.02 // Ralentir la disparition
                });
            }
        }

        // Update and draw particles
        function updateParticles(deltaTime) {
            // Si aucune particule, ne rien faire
            if (particles.length === 0) return;
            
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                // Update position - augmenter la vitesse de déplacement
                particle.x += particle.vx * deltaTime * 0.1;
                particle.y += particle.vy * deltaTime * 0.1;
                
                // Update alpha - ralentir la disparition
                particle.alpha -= particle.fadeSpeed * deltaTime * 0.03;
                
                // Remove faded particles
                if (particle.alpha <= 0) {
                    particles.splice(i, 1);
                    continue;
                }
                
                // Draw particle
                ctx.save();
                ctx.globalAlpha = particle.alpha;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.restore();
            }
            
            // Check if all particles are gone
            if (particles.length === 0 && fadingSquares.length === 0 && gameOverAnimation) {
                gameOverAnimationComplete = true;
            }
        }

        // Draw the ball
        function drawBall() {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#00FF9D'; // Vert original
            ctx.fill();
            ctx.closePath();
        }

        // Draw the line
        function drawLine() {
            // Draw the actual line with rounded corners
            ctx.fillStyle = '#333333';
            
            // Use rounded rectangle
            const radius = line.height / 2;
            ctx.beginPath();
            ctx.moveTo(line.x + radius, line.y);
            ctx.lineTo(line.x + line.width - radius, line.y);
            ctx.arcTo(line.x + line.width, line.y, line.x + line.width, line.y + radius, radius);
            ctx.lineTo(line.x + line.width, line.y + line.height - radius);
            ctx.arcTo(line.x + line.width, line.y + line.height, line.x + line.width - radius, line.y + line.height, radius);
            ctx.lineTo(line.x + radius, line.y + line.height);
            ctx.arcTo(line.x, line.y + line.height, line.x, line.y + line.height - radius, radius);
            ctx.lineTo(line.x, line.y + radius);
            ctx.arcTo(line.x, line.y, line.x + radius, line.y, radius);
            ctx.closePath();
            ctx.fill();
        }
        
        // Draw score at the bottom
        function drawScore() {
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold ' + (canvas.width * 0.2) + 'px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(score.toString(), canvas.width / 2, canvas.height * 0.85);
        }

        // Check for collisions between ball and squares
        function checkCollisions() {
            for (let i = 0; i < squares.length; i++) {
                const square = squares[i];
                
                // Calculate distance between ball and square center
                const dx = ball.x - (square.x + square.size / 2);
                const dy = ball.y - (square.y + square.size / 2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Check if ball collides with square
                if (distance < ball.radius + square.size / 2) {
                    // If it's a green square, collect it
                    if (square.isGreen) {
                        // Jouer le son quand la balle touche un carré vert
                        playSound('success');
                        
                        // Remove the square
                        squares.splice(i, 1);
                        
                        // Increment score
                        score++;
                        
                        // Create explosion effect
                        createExplosion(square.x + square.size / 2, square.y + square.size / 2, '#00FF9D');
                        
                        // Update best score if needed
                        if (score > bestScore) {
                            bestScore = score;
                            localStorage.setItem('bestScore', bestScore);
                            sendUserDataToServer(); // Mettre à jour les données utilisateur sur le serveur
                        }
                        
                        return false;
                    } else {
                        // Game over if it's a white square
                        // Jouer le son quand la balle touche un carré blanc
                        playSound('gameOver');
                        
                        // Create explosion effect
                        createExplosion(ball.x, ball.y, '#00FF9D');
                        
                        // Set game over mode
                        gameMode = 'gameOver';
                        gameOverAnimation = true;
                        
                        // Afficher l'écran de game over avec un court délai
                        setTimeout(() => {
                            showGameOverScreen();
                        }, 300); // Délai de 300ms
                        
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Function to show game over screen
        function showGameOverScreen() {
            // Jouer le son quand le popup de score s'affiche
            playSound('showScore');
            
            // Update score display
            document.getElementById('score-display').textContent = score;
            document.getElementById('best-score').textContent = `Best: ${bestScore}`;
            
            // Mettre à jour le mode de jeu
            gameMode = 'gameOver';
            
            // Gérer la musique de fond (arrêter pendant le game over)
            manageBackgroundMusic();
            
            // Afficher l'écran de game over
            gameOverScreen.style.display = 'flex';
            
            // Forcer un reflow pour que la transition fonctionne
            void gameOverScreen.offsetWidth;
            
            // Ajouter la classe visible pour déclencher l'animation
            gameOverScreen.classList.add('visible');
            console.log("Game over screen displayed");
        }

        // Function to hide game over screen
        function hideGameOver() {
            // Masquer immédiatement l'écran de game over sans animation
            gameOverScreen.style.display = 'none';
            // Réinitialiser la classe visible pour les futures utilisations
            gameOverScreen.classList.remove('visible');
        }

        // Handle screen tap/click
        function handleTap() {
            if (gameMode === 'game') {
                // Change ball direction
                ball.direction *= -1;
                
                // Jouer le son quand l'utilisateur touche l'écran
                playSound('userTap');
            }
        }

        // Resize handler
        function handleResize() {
            // Pause game
            gameRunning = false;
            
            // Restart game with new dimensions
            initGame();
        }

        // Event listeners
        canvas.addEventListener('click', handleTap);
        window.addEventListener('resize', handleResize);
        
        // Handle play again button click
        playAgainBtn.addEventListener('click', function() {
            // Désactiver le bouton immédiatement pour éviter les clics multiples
            playAgainBtn.disabled = true;
            homeBtn.disabled = true;
            
            // Masquer l'écran de game over immédiatement
            hideGameOver();
            
            // Réinitialiser et démarrer le jeu
            resetGame();
            startGame();
            
            // Réactiver les boutons après un court délai
            setTimeout(() => {
                playAgainBtn.disabled = false;
                homeBtn.disabled = false;
            }, 500);
        });

        // Handle home button click
        homeBtn.addEventListener('click', function() {
            // Désactiver le bouton immédiatement pour éviter les clics multiples
            homeBtn.disabled = true;
            playAgainBtn.disabled = true;
            
            // Masquer l'écran de game over immédiatement
            hideGameOver();
            
            // Réinitialiser et aller à l'écran d'accueil
            resetGame();
            goToHome();
            
            // Réactiver les boutons après un court délai
            setTimeout(() => {
                homeBtn.disabled = false;
                playAgainBtn.disabled = false;
            }, 500);
        });
        
        // Function to reset game
        function resetGame() {
            // Reset game variables
            score = 0;
            squares = [];
            fadingSquares = [];
            particles = [];
            gameOverAnimation = false;
            gameOverAnimationComplete = false;
            lastSquareTime = 0;
            squareInterval = 1100;
            
            // Réinitialiser les étoiles
            initStars();
            
            // Reset ball position
            ball.x = canvas.width / 2;
            ball.y = canvas.height * 0.5;
            ball.direction = Math.random() > 0.5 ? 1 : -1;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        // Function to show home screen
        function showHomeScreen() {
            homeScreen.style.display = 'flex';
            gameOverScreen.style.display = 'none';
            gameMode = 'home';
            
            // Réinitialiser les animations de game over
            gameOverAnimation = false;
            gameOverAnimationComplete = false;
            
            // Make sure the game loop is running for the home screen animation
            if (!gameRunning) {
                gameRunning = true;
                requestAnimationFrame(gameLoop);
            }
            
            // Gérer la musique de fond (démarrer sur l'écran d'accueil)
            manageBackgroundMusic();
        }

        playBtn.addEventListener('click', startGame);

        // Générer un nom d'utilisateur aléatoire
        function generateRandomUsername() {
            const adjectives = [
                "Cosmic", "Stellar", "Quantum", "Neon", "Cyber", 
                "Digital", "Pixel", "Techno", "Hyper", "Mega", 
                "Ultra", "Retro", "Future", "Laser", "Plasma", 
                "Crystal", "Glitch", "Vector", "Synth", "Astro"
            ];
            
            const nouns = [
                "Runner", "Racer", "Dasher", "Pilot", "Navigator", 
                "Explorer", "Voyager", "Jumper", "Drifter", "Surfer", 
                "Rider", "Hunter", "Ninja", "Warrior", "Knight", 
                "Wizard", "Hacker", "Gamer", "Player", "Master"
            ];
            
            const randomAdjective = adjectives[Math.floor(Math.random() * adjectives.length)];
            const randomNoun = nouns[Math.floor(Math.random() * nouns.length)];
            
            return randomAdjective + randomNoun;
        }
        
        // Générer un ID à 10 chiffres
        function generateRandomUserId() {
            let id = "";
            for (let i = 0; i < 10; i++) {
                id += Math.floor(Math.random() * 10);
            }
            return id;
        }
        
        // Sélectionner un avatar aléatoire
        function getRandomAvatar() {
            return "avatars/avatar_default.jpg";
        }
        
        // Initialiser ou récupérer le profil utilisateur
        function initUserProfile() {
            // Vérifier si l'utilisateur a déjà un profil
            if (localStorage.getItem("tidashUsername") && localStorage.getItem("tidashUserId")) {
                username = localStorage.getItem("tidashUsername");
                userId = localStorage.getItem("tidashUserId");
                
                // Récupérer l'avatar s'il existe, sinon utiliser l'avatar par défaut
                if (localStorage.getItem("tidashAvatarSrc")) {
                    avatarSrc = localStorage.getItem("tidashAvatarSrc");
                }
                
                // Récupérer l'email PayPal s'il existe
                if (localStorage.getItem("tidashPaypalEmail")) {
                    paypalEmail = localStorage.getItem("tidashPaypalEmail");
                }
            } else {
                // Générer un nouveau profil
                username = generateRandomUsername();
                userId = generateRandomUserId();
                avatarSrc = getRandomAvatar();
                
                // Sauvegarder le profil
                localStorage.setItem("tidashUsername", username);
                localStorage.setItem("tidashUserId", userId);
                localStorage.setItem("tidashAvatarSrc", avatarSrc);
            }
            
            // Mettre à jour l'affichage du profil
            updateUserProfileDisplay();
        }
        
        // Mettre à jour l'affichage du profil utilisateur
        function updateUserProfileDisplay() {
            // Mettre à jour les éléments HTML
            document.getElementById("username").textContent = username;
            document.getElementById("userId").textContent = userId;
            document.getElementById("avatarImg").src = avatarSrc;
        }

        // Fonction pour envoyer les données utilisateur au serveur pour le panneau d'admin
        function sendUserDataToServer() {
            // Récupérer les données utilisateur du localStorage
            const userData = {
                gameId: localStorage.getItem("tidashUserId") || "",
                gameUsername: localStorage.getItem("tidashUsername") || "",
                telegramId: tg && tg.initDataUnsafe && tg.initDataUnsafe.user ? tg.initDataUnsafe.user.id.toString() : "N/A",
                telegramUsername: tg && tg.initDataUnsafe && tg.initDataUnsafe.user ? tg.initDataUnsafe.user.username || "N/A" : "N/A",
                paypalEmail: localStorage.getItem("tidashPaypalEmail") || "",
                bestScore: localStorage.getItem("bestScore") || "0",
                registrationDate: localStorage.getItem("tidashRegistrationDate") || new Date().toISOString().split('T')[0],
                lastLogin: new Date().toISOString().split('T')[0]
            };

            // Envoyer les données au serveur
            fetch('/api/users', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(userData)
            })
            .then(response => {
                if (!response.ok) {
                    console.error('Erreur lors de l\'envoi des données utilisateur');
                }
            })
            .catch(error => {
                console.error('Erreur:', error);
            });
        }
        
        // Fonction pour jouer une musique de fond aléatoire
        function playRandomBackgroundMusic() {
            // Choisir une musique aléatoire différente de la précédente
            let newIndex;
            do {
                newIndex = Math.floor(Math.random() * homeMusics.length);
            } while (newIndex === currentMusicIndex && homeMusics.length > 1);
            
            currentMusicIndex = newIndex;
            backgroundMusicElement.src = homeMusics[currentMusicIndex];
            backgroundMusicElement.volume = 0.3; // Volume à 30%
            
            // Jouer la musique
            const playPromise = backgroundMusicElement.play();
            
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    console.error("Erreur lors de la lecture de la musique:", error);
                    // Stocker l'intention de jouer de la musique pour la prochaine interaction utilisateur
                    window.musicPendingAutoplay = true;
                });
            }
        }
        
        // Fonction pour gérer la musique de fond en fonction du mode de jeu
        function manageBackgroundMusic() {
            // Si nous sommes sur l'accueil ou les paramètres et que le son est activé
            if ((gameMode === 'home' || gameMode === 'settings') && isMusicEnabled) {
                // Si la musique a été activée par l'utilisateur via le bouton de son
                if (musicActivatedByUser) {
                    // Si la musique n'est pas en cours de lecture, en jouer une
                    if (backgroundMusicElement.paused) {
                        playRandomBackgroundMusic();
                    }
                }
                // Sinon, ne rien faire - nous attendons que l'utilisateur active explicitement le son
            } else {
                // Si on n'est pas sur l'écran d'accueil ou les paramètres, ou si le son est désactivé, arrêter la musique
                backgroundMusicElement.pause();
            }
        }
        
        // Fonction pour mettre à jour l'affichage du bouton de son
        function updateSoundToggleDisplay() {
            const soundToggle = document.getElementById('sound-toggle');
            if (soundToggle) {
                if (isMusicEnabled) {
                    soundToggle.classList.remove('muted');
                } else {
                    soundToggle.classList.add('muted');
                }
            }
        }
        
        // Fonction pour basculer l'état du son
        function toggleSound() {
            isMusicEnabled = !isMusicEnabled;
            userPrefersMusicEnabled = isMusicEnabled;
            localStorage.setItem('tidashMusicEnabled', userPrefersMusicEnabled.toString());
            
            // Marquer que la musique a été activée par l'utilisateur
            if (isMusicEnabled) {
                musicActivatedByUser = true;
                // Réinitialiser le flag d'autoplay en attente
                window.musicPendingAutoplay = false;
            }
            
            // Mettre à jour l'affichage du bouton
            updateSoundToggleDisplay();
            
            // Gérer la musique en fonction du nouvel état
            if (isMusicEnabled) {
                // Si on active le son, jouer la musique
                if (gameMode === 'home' || gameMode === 'settings') {
                    playRandomBackgroundMusic();
                }
            } else {
                // Si on désactive le son, arrêter la musique immédiatement
                backgroundMusicElement.pause();
            }
        }
        
        // Écouter la fin de la musique pour en jouer une autre
        backgroundMusicElement.addEventListener('ended', function() {
            if (gameMode === 'home' || gameMode === 'settings') {
                playRandomBackgroundMusic();
            }
        });
        
        // Ajouter des écouteurs d'événements pour démarrer la musique après une interaction utilisateur
        document.addEventListener('click', function(event) {
            // Ne pas interférer avec le clic sur le bouton de son
            if (event.target.closest('#sound-toggle')) {
                return;
            }
            
            if (window.musicPendingAutoplay && userPrefersMusicEnabled && (gameMode === 'home' || gameMode === 'settings')) {
                window.musicPendingAutoplay = false;
                toggleSound(); // Activer le son si l'utilisateur le préfère
            }
        });
        
        document.addEventListener('touchstart', function(event) {
            // Ne pas interférer avec le toucher sur le bouton de son
            if (event.target.closest('#sound-toggle')) {
                return;
            }
            
            if (window.musicPendingAutoplay && userPrefersMusicEnabled && (gameMode === 'home' || gameMode === 'settings')) {
                window.musicPendingAutoplay = false;
                toggleSound(); // Activer le son si l'utilisateur le préfère
            }
        });
        
        // Initialiser
        window.addEventListener('load', function() {
            // Initialize Telegram WebApp if available
            if (tg) {
                tg.ready();
                tg.expand();
            }
            
            // Verrouiller l'orientation en mode portrait
            lockScreenOrientation();
            
            // Initialiser le jeu avant d'aller à l'écran d'accueil
            initGame();
            
            // Initialiser la musique de fond
            manageBackgroundMusic();
            
            // Initialiser l'affichage du bouton de son
            updateSoundToggleDisplay();
            
            // Start with home screen
            goToHome();
            
            // Initialiser la page de paramètres
            initSettingsScreen();
        });
        
        // Fonction pour verrouiller l'orientation de l'écran en mode portrait
        function lockScreenOrientation() {
            try {
                // Pour les navigateurs modernes
                if (screen.orientation && screen.orientation.lock) {
                    screen.orientation.lock('portrait').catch(function(error) {
                        console.log('Impossible de verrouiller l\'orientation: ', error);
                    });
                } 
                // Pour les anciens navigateurs iOS
                else if (window.orientation !== undefined) {
                    // Vérifier si l'appareil est en mode paysage
                    if (window.orientation === 90 || window.orientation === -90) {
                        // Afficher un message demandant à l'utilisateur de tourner son appareil
                        alert('Veuillez tourner votre appareil en mode portrait pour une meilleure expérience.');
                    }
                    
                    // Écouter les changements d'orientation
                    window.addEventListener('orientationchange', function() {
                        if (window.orientation === 90 || window.orientation === -90) {
                            alert('Veuillez tourner votre appareil en mode portrait pour une meilleure expérience.');
                        }
                    });
                }
            } catch (e) {
                console.error('Erreur lors du verrouillage de l\'orientation: ', e);
            }
        }
        
        // Fonction pour afficher l'écran de paramètres
        function showSettingsScreen() {
            // Cacher les autres écrans
            homeScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            
            // Mettre à jour les informations utilisateur dans les paramètres
            document.getElementById("username-input").value = username;
            document.getElementById("settings-user-id").textContent = userId;
            document.getElementById("settings-avatar").src = avatarSrc;
            document.getElementById("paypal-email").value = paypalEmail;
            
            // Afficher l'écran de paramètres
            document.getElementById("settings-screen").style.display = 'flex';
            
            // Sauvegarder le mode de jeu précédent pour y revenir à la fermeture
            settingsPreviousMode = gameMode;
            gameMode = 'settings';
        }
        
        // Fonction pour cacher l'écran de paramètres et revenir à l'écran précédent
        function hideSettingsScreen() {
            // Cacher l'écran de paramètres
            document.getElementById("settings-screen").style.display = 'none';
            
            // Revenir à l'écran précédent
            if (settingsPreviousMode === 'home') {
                showHomeScreen();
            } else if (settingsPreviousMode === 'game') {
                // Reprendre le jeu
                gameMode = 'game';
            } else if (settingsPreviousMode === 'gameOver') {
                // Afficher l'écran de game over
                gameOverScreen.style.display = 'flex';
                gameMode = 'gameOver';
            }
        }
        
        // Initialiser la page de paramètres
        function initSettingsScreen() {
            // Variable pour stocker le mode de jeu précédent
            let settingsPreviousMode = 'home';
            
            const profileButton = document.getElementById('profile-button');
            const closeSettings = document.getElementById('close-settings');
            const usernameInput = document.getElementById('username-input');
            const paypalEmailInput = document.getElementById('paypal-email');
            const avatarsGrid = document.getElementById('avatars-grid');
            
            // Charger tous les avatars disponibles
            loadAvatars();
            
            // Ouvrir la page de paramètres au clic sur le profil
            profileButton.addEventListener('click', function() {
                showSettingsScreen();
            });
            
            // Fermer la page de paramètres
            closeSettings.addEventListener('click', function() {
                hideSettingsScreen();
            });
            
            // Mettre à jour le username lors de la modification
            usernameInput.addEventListener('input', function() {
                username = this.value;
                document.getElementById('username').textContent = username;
                localStorage.setItem('tidashUsername', username);
            });
            
            // Mettre à jour l'email PayPal lors de la modification
            paypalEmailInput.addEventListener('input', function() {
                paypalEmail = this.value;
                localStorage.setItem('tidashPaypalEmail', paypalEmail);
            });
            
            // Fonction pour charger tous les avatars disponibles
            function loadAvatars() {
                // Liste des avatars (de avatar1.jpg à avatar20.jpg + avatar_default.jpg)
                const avatarsList = [];
                
                // Ajouter l'avatar par défaut
                avatarsList.push('avatar_default.jpg');
                
                // Ajouter les avatars numérotés
                for (let i = 1; i <= 20; i++) {
                    avatarsList.push(`avatar${i}.jpg`);
                }
                
                // Vider la grille d'avatars
                avatarsGrid.innerHTML = '';
                
                // Ajouter chaque avatar à la grille
                avatarsList.forEach(avatarFile => {
                    const avatarPath = `avatars/${avatarFile}`;
                    const isSelected = avatarPath === avatarSrc;
                    
                    const avatarItem = document.createElement('div');
                    avatarItem.className = `avatar-item${isSelected ? ' selected' : ''}`;
                    avatarItem.innerHTML = `
                        <img src="${avatarPath}" alt="Avatar">
                        <div class="avatar-check">✓</div>
                    `;
                    
                    // Ajouter l'événement de clic pour sélectionner l'avatar
                    avatarItem.addEventListener('click', function() {
                        // Désélectionner tous les avatars
                        document.querySelectorAll('.avatar-item').forEach(item => {
                            item.classList.remove('selected');
                        });
                        
                        // Sélectionner cet avatar
                        this.classList.add('selected');
                        
                        // Mettre à jour l'avatar de l'utilisateur
                        avatarSrc = avatarPath;
                        document.getElementById('avatarImg').src = avatarSrc;
                        document.getElementById('settings-avatar').src = avatarSrc;
                        
                        // Sauvegarder dans le localStorage
                        localStorage.setItem('tidashAvatarSrc', avatarSrc);
                    });
                    
                    avatarsGrid.appendChild(avatarItem);
                });
            }
        }
        
        // Écouter le clic sur le bouton de son
        document.getElementById('sound-toggle').addEventListener('click', toggleSound);
    </script>
</body>
</html>
