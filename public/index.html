<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TiDash Game</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body {
            font-family: Arial, Helvetica, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #ffffff;
            overflow: hidden;
        }
        .container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 500px;
            max-height: 800px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #game-canvas {
            background-color: #ffffff;
            display: block;
        }
        .score {
            position: absolute;
            top: 20px;
            font-size: 4rem;
            color: #000000;
            font-weight: normal;
            font-family: Arial, Helvetica, sans-serif;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="score">9</div>
        <canvas id="game-canvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const tg = window.Telegram.WebApp;

        // Set canvas size
        function resizeCanvas() {
            const container = document.querySelector('.container');
            const size = Math.min(container.clientWidth, container.clientHeight) * 0.8;
            canvas.width = size;
            canvas.height = size;
            drawScene();
        }

        // Colors
        const COLORS = {
            path: '#d3d3d3',        // Light gray for path
            cube: '#333333',        // Black cube
            background: '#ffffff'   // White background
        };

        // Isometric settings
        const ISO = {
            scale: 1,
            angle: Math.PI / 6,     // 30 degrees
            pathWidth: 40,          // Width of the path
            cubeSize: 20            // Size of the cube
        };

        // Draw the scene
        function drawScene() {
            // Clear the canvas
            ctx.fillStyle = COLORS.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Set the origin to the center of the canvas
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2 + 40; // Adjust to match reference
            
            // Draw the zigzag path
            drawIsometricPath(centerX, centerY);
            
            // Draw the cube
            drawIsometricCube(centerX, centerY);
        }

        // Draw the isometric zigzag path
        function drawIsometricPath(centerX, centerY) {
            ctx.fillStyle = COLORS.path;
            
            // Calculate path points for a zigzag matching the reference image
            const pathSegments = [
                { x: -140, y: 80 },    // Start point
                { x: -20, y: 80 },     // First segment
                { x: -20, y: 0 },      // Second segment (turn)
                { x: -100, y: 0 },     // Third segment (turn)
                { x: -100, y: -80 },   // Fourth segment (turn)
                { x: 20, y: -80 }      // End point
            ];
            
            // Draw each path segment
            for (let i = 0; i < pathSegments.length - 1; i++) {
                const startX = centerX + toIsoX(pathSegments[i].x, pathSegments[i].y);
                const startY = centerY + toIsoY(pathSegments[i].x, pathSegments[i].y);
                const endX = centerX + toIsoX(pathSegments[i+1].x, pathSegments[i+1].y);
                const endY = centerY + toIsoY(pathSegments[i+1].x, pathSegments[i+1].y);
                
                drawPathSegment(startX, startY, endX, endY);
            }
        }
        
        // Draw a single path segment
        function drawPathSegment(startX, startY, endX, endY) {
            const width = ISO.pathWidth;
            const halfWidth = width / 2;
            
            // Calculate perpendicular vector
            const dx = endX - startX;
            const dy = endY - startY;
            const length = Math.sqrt(dx * dx + dy * dy);
            const perpX = -dy / length * halfWidth;
            const perpY = dx / length * halfWidth;
            
            // Draw the path segment
            ctx.beginPath();
            ctx.moveTo(startX + perpX, startY + perpY);
            ctx.lineTo(endX + perpX, endY + perpY);
            ctx.lineTo(endX - perpX, endY - perpY);
            ctx.lineTo(startX - perpX, startY - perpY);
            ctx.closePath();
            ctx.fill();
        }
        
        // Draw the isometric cube
        function drawIsometricCube(centerX, centerY) {
            // Position the cube at the third turn point to match reference
            const cubeX = centerX + toIsoX(-100, 0);
            const cubeY = centerY + toIsoY(-100, 0);
            const size = ISO.cubeSize;
            
            // Draw a black cube
            ctx.fillStyle = COLORS.cube;
            
            // Top face
            ctx.beginPath();
            ctx.moveTo(cubeX, cubeY - size/2);
            ctx.lineTo(cubeX + size/2, cubeY - size/4);
            ctx.lineTo(cubeX, cubeY);
            ctx.lineTo(cubeX - size/2, cubeY - size/4);
            ctx.closePath();
            ctx.fill();
            
            // Right face
            ctx.beginPath();
            ctx.moveTo(cubeX, cubeY);
            ctx.lineTo(cubeX + size/2, cubeY - size/4);
            ctx.lineTo(cubeX + size/2, cubeY + size/4);
            ctx.lineTo(cubeX, cubeY + size/2);
            ctx.closePath();
            ctx.fill();
            
            // Left face
            ctx.beginPath();
            ctx.moveTo(cubeX, cubeY);
            ctx.lineTo(cubeX - size/2, cubeY - size/4);
            ctx.lineTo(cubeX - size/2, cubeY + size/4);
            ctx.lineTo(cubeX, cubeY + size/2);
            ctx.closePath();
            ctx.fill();
        }
        
        // Convert Cartesian to Isometric X
        function toIsoX(x, y) {
            return (x - y) * Math.cos(ISO.angle) * ISO.scale;
        }
        
        // Convert Cartesian to Isometric Y
        function toIsoY(x, y) {
            return (x + y) * Math.sin(ISO.angle) * ISO.scale;
        }

        // Initialize
        window.addEventListener('load', function() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Initialize Telegram WebApp if available
            if (tg) {
                tg.ready();
                tg.expand();
            }
        });
    </script>
</body>
</html>
